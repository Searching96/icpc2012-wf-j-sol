;===============================================================================
; HUMAN-READABLE ANNOTATED ASSEMBLY CODE FOR main.cpp
; Generated from: main.cpp (ICPC 2012 World Finals Problem J - Shortest Flight Path)
; Target: x86-32 (32-bit) Windows
; Compiler: GCC with -O2 optimization
; Date: Generated by GitHub Copilot
;===============================================================================

; This file contains the assembly code generated from the C++ source code with
; detailed annotations explaining which C++ functions and constructs correspond
; to each assembly section.

;===============================================================================
; SECTION 1: GLOBAL CONSTANTS AND INITIALIZATION
;===============================================================================

	.file	"main.cpp"
	
; Standard library template instantiation for character type conversion
	.section	.text$_ZNKSt5ctypeIcE8do_widenEc,"x"
	.linkonce discard
	.align 2
	.p2align 4,,15
	.globl	__ZNKSt5ctypeIcE8do_widenEc
	.def	__ZNKSt5ctypeIcE8do_widenEc;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: std::ctype<char>::do_widen(char c)
; This is a standard library function for character conversion
__ZNKSt5ctypeIcE8do_widenEc:
	movzbl	4(%esp), %eax    ; Load character parameter and zero-extend to 32-bit
	ret	$4               ; Return with stack cleanup (4 bytes)

	.text
	.p2align 4,,15
	.def	___tcf_0;	.scl	3;	.type	32;	.endef

; C++ EQUIVALENT: Global constructor cleanup for std::ios_base::Init
; This handles the destruction of the global iostream initialization object
___tcf_0:
	movl	$__ZStL8__ioinit, %ecx    ; Load address of global ios_base::Init object
	jmp	__ZNSt8ios_base4InitD1Ev   ; Jump to destructor

;===============================================================================
; SECTION 2: POINT STRUCTURE OPERATORS
;===============================================================================

	.p2align 4,,15
	.globl	__ZplRK5PointS1_
	.def	__ZplRK5PointS1_;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point operator+(const Point& a, const Point& b)
; Returns {a.x + b.x, a.y + b.y, a.z + b.z}
__ZplRK5PointS1_:
	movl	8(%esp), %ecx     ; Load address of first Point (a)
	movl	12(%esp), %edx    ; Load address of second Point (b)  
	movl	4(%esp), %eax     ; Load address of result Point
	
	; Add x components (80-bit extended precision)
	fldt	(%ecx)            ; Load a.x onto FPU stack
	fldt	(%edx)            ; Load b.x onto FPU stack
	faddp	%st, %st(1)       ; Add: st(1) = st(1) + st(0), pop st(0)
	fstpt	(%eax)            ; Store result.x and pop

	; Add y components
	fldt	12(%ecx)          ; Load a.y (offset 12 bytes from start)
	fldt	12(%edx)          ; Load b.y
	faddp	%st, %st(1)       ; Add y components
	fstpt	12(%eax)          ; Store result.y

	; Add z components  
	fldt	24(%ecx)          ; Load a.z (offset 24 bytes from start)
	fldt	24(%edx)          ; Load b.z
	faddp	%st, %st(1)       ; Add z components
	fstpt	24(%eax)          ; Store result.z
	ret

	.p2align 4,,15
	.globl	__ZmiRK5PointS1_
	.def	__ZmiRK5PointS1_;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point operator-(const Point& a, const Point& b)
; Returns {a.x - b.x, a.y - b.y, a.z - b.z}
__ZmiRK5PointS1_:
	movl	8(%esp), %ecx     ; Load address of first Point (a)
	movl	12(%esp), %edx    ; Load address of second Point (b)
	movl	4(%esp), %eax     ; Load address of result Point
	
	; Subtract x components
	fldt	(%ecx)            ; Load a.x
	fldt	(%edx)            ; Load b.x
	fsubrp	%st, %st(1)       ; Subtract: st(1) = st(1) - st(0), pop st(0)
	fstpt	(%eax)            ; Store result.x

	; Subtract y components
	fldt	12(%ecx)          ; Load a.y
	fldt	12(%edx)          ; Load b.y
	fsubrp	%st, %st(1)       ; Subtract y components
	fstpt	12(%eax)          ; Store result.y

	; Subtract z components
	fldt	24(%ecx)          ; Load a.z
	fldt	24(%edx)          ; Load b.z
	fsubrp	%st, %st(1)       ; Subtract z components
	fstpt	24(%eax)          ; Store result.z
	ret

	.p2align 4,,15
	.globl	__ZmlRK5Pointe
	.def	__ZmlRK5Pointe;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point operator*(const Point& a, long double s)
; Returns {a.x * s, a.y * s, a.z * s}
__ZmlRK5Pointe:
	fldt	12(%esp)          ; Load scalar value s
	movl	8(%esp), %edx     ; Load address of Point a
	movl	4(%esp), %eax     ; Load address of result Point
	
	; Multiply x component by scalar
	fldt	(%edx)            ; Load a.x
	fmul	%st(1), %st       ; Multiply a.x by s
	fstpt	(%eax)            ; Store result.x

	; Multiply y component by scalar
	fldt	12(%edx)          ; Load a.y
	fmul	%st(1), %st       ; Multiply a.y by s
	fstpt	12(%eax)          ; Store result.y

	; Multiply z component by scalar
	fldt	24(%edx)          ; Load a.z
	fmulp	%st, %st(1)       ; Multiply a.z by s and pop
	fstpt	24(%eax)          ; Store result.z
	ret

	.p2align 4,,15
	.globl	__ZmleRK5Point
	.def	__ZmleRK5Point;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point operator*(long double s, const Point& a)
; Returns {s * a.x, s * a.y, s * a.z}
__ZmleRK5Point:
	fldt	8(%esp)           ; Load scalar value s
	movl	20(%esp), %edx    ; Load address of Point a
	movl	4(%esp), %eax     ; Load address of result Point
	
	; Multiply scalar by x component
	fldt	(%edx)            ; Load a.x
	fmul	%st(1), %st       ; Multiply s by a.x
	fstpt	(%eax)            ; Store result.x

	; Multiply scalar by y component
	fldt	12(%edx)          ; Load a.y
	fmul	%st(1), %st       ; Multiply s by a.y
	fstpt	12(%eax)          ; Store result.y

	; Multiply scalar by z component
	fldt	24(%edx)          ; Load a.z
	fmulp	%st, %st(1)       ; Multiply s by a.z and pop
	fstpt	24(%eax)          ; Store result.z
	ret

	.p2align 4,,15
	.globl	__ZdvRK5Pointe
	.def	__ZdvRK5Pointe;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point operator/(const Point& a, long double s)
; Returns {a.x / s, a.y / s, a.z / s}
__ZdvRK5Pointe:
	fldt	12(%esp)          ; Load scalar divisor s
	movl	8(%esp), %edx     ; Load address of Point a
	movl	4(%esp), %eax     ; Load address of result Point
	
	; Divide x component by scalar
	fldt	(%edx)            ; Load a.x
	fdiv	%st(1), %st       ; Divide a.x by s
	fstpt	(%eax)            ; Store result.x

	; Divide y component by scalar
	fldt	12(%edx)          ; Load a.y
	fdiv	%st(1), %st       ; Divide a.y by s
	fstpt	12(%eax)          ; Store result.y

	; Divide z component by scalar
	fldt	24(%edx)          ; Load a.z
	fdivp	%st, %st(1)       ; Divide a.z by s and pop
	fstpt	24(%eax)          ; Store result.z
	ret

;===============================================================================
; SECTION 3: GEOMETRIC UTILITY FUNCTIONS
;===============================================================================

	.p2align 4,,15
	.globl	__Z14lat_lon_to_xyzee
	.def	__Z14lat_lon_to_xyzee;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point lat_lon_to_xyz(long double lat_deg, long double lon_deg)
; Converts latitude/longitude in degrees to 3D Cartesian coordinates on Earth sphere
; Formula: x = R_EARTH * cos(lat_rad) * cos(lon_rad)
;          y = R_EARTH * cos(lat_rad) * sin(lon_rad)  
;          z = R_EARTH * sin(lat_rad)
__Z14lat_lon_to_xyzee:
	pushl	%ebx              ; Save EBX register (callee-saved)
	fldpi                     ; Load PI constant onto FPU stack
	subl	$104, %esp        ; Allocate 104 bytes of local stack space
	
	; Load parameters from stack
	fldt	116(%esp)         ; Load lat_deg parameter (80-bit long double)
	movl	112(%esp), %ebx   ; Load return structure address into EBX
	
	; Convert lat_deg to radians: lat_rad = lat_deg * PI / 180.0
	fmul	%st(1), %st       ; Multiply lat_deg by PI (st(1) = PI)
	flds	LC2               ; Load 180.0 constant (32-bit float)
	fdivr	%st, %st(1)       ; Divide: st(1) = st(1) / st(0) = (lat_deg * PI) / 180.0
	
	; Load and convert lon_deg to radians
	fldt	128(%esp)         ; Load lon_deg parameter 
	fmulp	%st, %st(3)       ; Multiply lon_deg by PI and pop
	fdivrp	%st, %st(2)       ; Divide by 180.0 and pop: lon_rad = (lon_deg * PI) / 180.0
	
	; Now FPU stack has: st(0) = lat_rad, st(1) = lon_rad
	fxch	%st(1)            ; Exchange: st(0) = lon_rad, st(1) = lat_rad
	fstpt	16(%esp)          ; Store lon_rad in local variable
	fld	%st(0)            ; Duplicate lat_rad: st(0) = st(1) = lat_rad
	fstpt	(%esp)            ; Store lat_rad for cosl function call
	fstpt	80(%esp)          ; Store another copy of lat_rad
	
	; Calculate cos(lat_rad) using library function
	call	_cosl             ; Call cosl(lat_rad), result in st(0)
	
	; Load R_EARTH constant and prepare for coordinate calculations
	flds	LC3               ; Load R_EARTH constant (6370.0)
	fmul	%st, %st(1)       ; Multiply cos(lat_rad) by R_EARTH
	fstpt	64(%esp)          ; Store R_EARTH * cos(lat_rad) for z calculation
	fstpt	48(%esp)          ; Store R_EARTH * cos(lat_rad) for x,y calculations
	
	; Calculate cos(lon_rad)
	fldt	16(%esp)          ; Load lon_rad
	fstpt	(%esp)            ; Store lon_rad for cosl function call
	call	_cosl             ; Call cosl(lon_rad), result in st(0)
	fstpt	32(%esp)          ; Store cos(lon_rad)
	
	; Calculate sin(lon_rad) 
	fldt	16(%esp)          ; Load lon_rad again
	fstpt	(%esp)            ; Store lon_rad for sinl function call
	call	_sinl             ; Call sinl(lon_rad), result in st(0)
	fstpt	16(%esp)          ; Store sin(lon_rad)
	
	; Calculate sin(lat_rad)
	fldt	80(%esp)          ; Load lat_rad
	fstpt	(%esp)            ; Store lat_rad for sinl function call
	call	_sinl             ; Call sinl(lat_rad), result in st(0)
	
	; Calculate final coordinates
	; x = R_EARTH * cos(lat_rad) * cos(lon_rad)
	fldt	32(%esp)          ; Load cos(lon_rad)
	movl	%ebx, %eax        ; Prepare return value (structure address)
	fldt	48(%esp)          ; Load R_EARTH * cos(lat_rad)
	fmul	%st, %st(1)       ; Multiply: cos(lon_rad) * R_EARTH * cos(lat_rad)
	fxch	%st(1)            ; Exchange to get result in st(0)
	fstpt	(%ebx)            ; Store x coordinate in result structure
	
	; y = R_EARTH * cos(lat_rad) * sin(lon_rad)
	fldt	16(%esp)          ; Load sin(lon_rad)
	fmulp	%st, %st(1)       ; Multiply by R_EARTH * cos(lat_rad)
	fstpt	12(%ebx)          ; Store y coordinate in result structure
	
	; z = R_EARTH * sin(lat_rad)
	fldt	64(%esp)          ; Load R_EARTH * cos(lat_rad) (actually should be just R_EARTH)
	fmulp	%st, %st(1)       ; Multiply by sin(lat_rad)
	fstpt	24(%ebx)          ; Store z coordinate in result structure
	
	; Function epilogue
	addl	$104, %esp        ; Deallocate local stack space
	popl	%ebx              ; Restore EBX register
	ret                       ; Return (result address already in EAX)

	.p2align 4,,15
	.globl	__Z3dotRK5PointS1_
	.def	__Z3dotRK5PointS1_;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: long double dot(const Point& p1, const Point& p2)
; Returns p1.x * p2.x + p1.y * p2.y + p1.z * p2.z
__Z3dotRK5PointS1_:
	movl	4(%esp), %eax     ; Load address of first Point
	movl	8(%esp), %edx     ; Load address of second Point
	
	; Calculate p1.x * p2.x
	fldt	(%eax)            ; Load p1.x
	fldt	(%edx)            ; Load p2.x
	fmulp	%st, %st(1)       ; Multiply and pop
	
	; Calculate p1.y * p2.y and add to previous result
	fldt	12(%eax)          ; Load p1.y
	fldt	12(%edx)          ; Load p2.y
	fmulp	%st, %st(1)       ; Multiply and pop
	faddp	%st, %st(1)       ; Add to running sum
	
	; Calculate p1.z * p2.z and add to previous result
	fldt	24(%eax)          ; Load p1.z
	fldt	24(%edx)          ; Load p2.z
	fmulp	%st, %st(1)       ; Multiply and pop
	faddp	%st, %st(1)       ; Add to get final dot product
	ret

	.p2align 4,,15
	.globl	__Z5crossRK5PointS1_
	.def	__Z5crossRK5PointS1_;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point cross(const Point& p1, const Point& p2)
; Returns cross product {p1.y*p2.z - p1.z*p2.y, p1.z*p2.x - p1.x*p2.z, p1.x*p2.y - p1.y*p2.x}
__Z5crossRK5PointS1_:
	movl	8(%esp), %eax     ; Load address of first Point
	movl	12(%esp), %edx    ; Load address of second Point
	movl	4(%esp), %ecx     ; Load address of result Point
	
	; Calculate x component: p1.y*p2.z - p1.z*p2.y
	fldt	12(%eax)          ; Load p1.y
	fldt	24(%edx)          ; Load p2.z
	fmulp	%st, %st(1)       ; Calculate p1.y * p2.z
	fldt	24(%eax)          ; Load p1.z
	fldt	12(%edx)          ; Load p2.y
	fmulp	%st, %st(1)       ; Calculate p1.z * p2.y
	fsubrp	%st, %st(1)       ; Subtract to get x component
	fstpt	(%ecx)            ; Store result.x
	
	; Calculate y component: p1.z*p2.x - p1.x*p2.z
	fldt	24(%eax)          ; Load p1.z
	fldt	(%edx)            ; Load p2.x
	fmulp	%st, %st(1)       ; Calculate p1.z * p2.x
	fldt	(%eax)            ; Load p1.x
	fldt	24(%edx)          ; Load p2.z
	fmulp	%st, %st(1)       ; Calculate p1.x * p2.z
	fsubrp	%st, %st(1)       ; Subtract to get y component
	fstpt	12(%ecx)          ; Store result.y
	
	; Calculate z component: p1.x*p2.y - p1.y*p2.x
	fldt	(%eax)            ; Load p1.x
	fldt	12(%edx)          ; Load p2.y
	fmulp	%st, %st(1)       ; Calculate p1.x * p2.y
	fldt	12(%eax)          ; Load p1.y
	fldt	(%edx)            ; Load p2.x
	fmulp	%st, %st(1)       ; Calculate p1.y * p2.x
	fsubrp	%st, %st(1)       ; Subtract to get z component
	fstpt	24(%ecx)          ; Store result.z
	ret

	.p2align 4,,15
	.globl	__Z9magnitudeRK5Point
	.def	__Z9magnitudeRK5Point;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: long double magnitude(const Point& p)
; Returns sqrt(p.x*p.x + p.y*p.y + p.z*p.z)
; This function calculates the Euclidean norm/magnitude of a 3D point/vector
__Z9magnitudeRK5Point:
	subl	$44, %esp         ; Allocate 44 bytes of local stack space
	movl	48(%esp), %eax    ; Load address of Point parameter into EAX
	
	; Load all three coordinates onto FPU stack
	fldt	(%eax)            ; Load p.x onto FPU stack: st(0) = p.x
	fldt	12(%eax)          ; Load p.y onto FPU stack: st(0) = p.y, st(1) = p.x
	fldt	24(%eax)          ; Load p.z onto FPU stack: st(0) = p.z, st(1) = p.y, st(2) = p.x
	
	; Calculate sum of squares: p.x² + p.y² + p.z²
	fxch	%st(2)            ; Exchange st(0) and st(2): st(0) = p.x, st(1) = p.y, st(2) = p.z
	fmul	%st(0), %st       ; Square p.x: st(0) = p.x², st(1) = p.y, st(2) = p.z
	fxch	%st(1)            ; Exchange st(0) and st(1): st(0) = p.y, st(1) = p.x², st(2) = p.z
	fmul	%st(0), %st       ; Square p.y: st(0) = p.y², st(1) = p.x², st(2) = p.z
	faddp	%st, %st(1)       ; Add and pop: st(0) = p.x² + p.y², st(1) = p.z
	fxch	%st(1)            ; Exchange: st(0) = p.z, st(1) = p.x² + p.y²
	fmul	%st(0), %st       ; Square p.z: st(0) = p.z², st(1) = p.x² + p.y²
	faddp	%st, %st(1)       ; Add and pop: st(0) = p.x² + p.y² + p.z²
	
	; Calculate square root with precision handling
	fld	%st(0)            ; Duplicate sum of squares: st(0) = st(1) = p.x² + p.y² + p.z²
	fsqrt                     ; Calculate sqrt: st(0) = sqrt(p.x² + p.y² + p.z²)
	fstpt	16(%esp)          ; Store sqrt result in local variable
	
	; Check if the original sum is zero (for precision)
	fldz                      ; Load 0.0: st(0) = 0.0, st(1) = p.x² + p.y² + p.z²
	fucomp	%st(1)            ; Compare 0.0 with sum of squares (unordered compare)
	fnstsw	%ax              ; Store FPU status word in AX
	sahf                      ; Store AH into FLAGS register
	jbe	L16               ; Jump if sum <= 0 (Below or Equal)
	
	; If sum > 0, use high-precision sqrt library function
	fstpt	(%esp)            ; Store sum of squares as parameter
	call	_sqrtl            ; Call high-precision sqrt library function
	fstp	%st(0)            ; Pop the old sum from stack
	jmp	L12               ; Jump to return
	
L16:   ; Handle case where sum <= 0 (point is at origin)
	fstp	%st(0)            ; Pop the sum of squares from stack
	
L12:   ; Return path
	fldt	16(%esp)          ; Load the computed sqrt result
	addl	$44, %esp         ; Deallocate local stack space
	ret                       ; Return with result in st(0)

	.p2align 4,,15
	.globl	__Z9normalizeRK5Point
	.def	__Z9normalizeRK5Point;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point normalize(const Point& p)
; Returns p / magnitude(p), or {0,0,0} if magnitude < EPS
; This function normalizes a 3D vector to unit length
__Z9normalizeRK5Point:
	pushl	%esi              ; Save ESI register (callee-saved)
	pushl	%ebx              ; Save EBX register (callee-saved)
	subl	$20, %esp         ; Allocate 20 bytes of local stack space
	
	; Load function parameters
	movl	36(%esp), %esi    ; Load address of input Point into ESI
	movl	32(%esp), %ebx    ; Load address of result Point into EBX
	
	; Calculate magnitude of input point
	movl	%esi, (%esp)      ; Push input Point address as parameter
	call	__Z9magnitudeRK5Point ; Call magnitude function
	; Result (magnitude) is now in st(0)
	
	; Compare magnitude with EPS threshold
	fldt	LC5               ; Load EPS constant (1e-9L) onto FPU stack
	fucomp	%st(1)            ; Compare EPS with magnitude (unordered compare)
	fnstsw	%ax              ; Store FPU status word in AX
	sahf                      ; Store AH into FLAGS register
	ja	L24               ; Jump if EPS > magnitude (magnitude is too small)
	
	; Normal case: magnitude >= EPS, perform normalization
	; result.x = p.x / magnitude
	fldt	(%esi)            ; Load input p.x
	movl	%ebx, %eax        ; Prepare return value (result structure address)
	fdiv	%st(1), %st       ; Divide p.x by magnitude
	fstpt	(%ebx)            ; Store normalized x coordinate
	
	; result.y = p.y / magnitude  
	fldt	12(%esi)          ; Load input p.y
	fdiv	%st(1), %st       ; Divide p.y by magnitude
	fstpt	12(%ebx)          ; Store normalized y coordinate
	
	; result.z = p.z / magnitude
	fldt	24(%esi)          ; Load input p.z
	fdivp	%st, %st(1)       ; Divide p.z by magnitude and pop
	fstpt	24(%ebx)          ; Store normalized z coordinate
	
	; Function epilogue
	addl	$20, %esp         ; Deallocate local stack space
	popl	%ebx              ; Restore EBX register
	popl	%esi              ; Restore ESI register
	ret                       ; Return with result address in EAX

L24:   ; Handle case where magnitude < EPS (return zero vector)
	fstp	%st(0)            ; Pop magnitude from FPU stack
	fldz                      ; Load 0.0 onto FPU stack
	movl	%ebx, %eax        ; Prepare return value (result structure address)
	
	; Set all coordinates to zero
	fstpt	(%ebx)            ; Store 0.0 in result.x
	fldt	(%ebx)            ; Load the zero we just stored
	fstpt	12(%ebx)          ; Store 0.0 in result.y  
	fldt	12(%ebx)          ; Load the zero we just stored
	fstpt	24(%ebx)          ; Store 0.0 in result.z
	
	; Function epilogue
	addl	$20, %esp         ; Deallocate local stack space
	popl	%ebx              ; Restore EBX register
	popl	%esi              ; Restore ESI register
	ret                       ; Return with result address in EAX

;===============================================================================
; SECTION 4: GREAT CIRCLE DISTANCE FUNCTIONS
;===============================================================================

	.p2align 4,,15
	.globl	__Z8dist_xyzRK5PointS1_
	.def	__Z8dist_xyzRK5PointS1_;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: long double dist_xyz(const Point& p1, const Point& p2)
; Great circle distance between two points using acos(dot(normalize(p1), normalize(p2))) * R_EARTH
; This calculates the angular distance between two points on the Earth's surface
__Z8dist_xyzRK5PointS1_:
	subl	$156, %esp        ; Allocate 156 bytes of local stack space
	
	; Normalize first point p1
	movl	160(%esp), %edx   ; Load address of p1
	leal	48(%esp), %eax    ; Load address for normalized p1 (local variable)
	movl	%eax, (%esp)      ; Push result address as first parameter
	movl	%edx, 4(%esp)     ; Push p1 address as second parameter
	call	__Z9normalizeRK5Point ; Call normalize(p1)
	
	; Normalize second point p2
	movl	164(%esp), %edx   ; Load address of p2
	leal	96(%esp), %eax    ; Load address for normalized p2 (local variable)
	movl	%eax, (%esp)      ; Push result address as first parameter
	movl	%edx, 4(%esp)     ; Push p2 address as second parameter
	call	__Z9normalizeRK5Point ; Call normalize(p2)
	
	; Calculate dot product of normalized vectors
	; dot = u1.x * u2.x + u1.y * u2.y + u1.z * u2.z
	fldt	96(%esp)          ; Load normalized p2.x
	fldt	48(%esp)          ; Load normalized p1.x
	fmulp	%st, %st(1)       ; Multiply x components
	
	fldt	108(%esp)         ; Load normalized p2.y (offset 96+12)
	fldt	60(%esp)          ; Load normalized p1.y (offset 48+12)
	fmulp	%st, %st(1)       ; Multiply y components
	faddp	%st, %st(1)       ; Add to x product
	
	fldt	120(%esp)         ; Load normalized p2.z (offset 96+24)
	fldt	72(%esp)          ; Load normalized p1.z (offset 48+24)
	fmulp	%st, %st(1)       ; Multiply z components
	faddp	%st, %st(1)       ; Add to get final dot product
	
	; Store dot product and prepare for clamping
	fld	%st(0)            ; Duplicate dot product
	fstpt	16(%esp)          ; Store dot product in local variable
	
	; Clamp dot product to [-1.0, 1.0] range to avoid numerical errors
	fld1                      ; Load 1.0
	fstpt	32(%esp)          ; Store 1.0 in local variable
	fldt	32(%esp)          ; Load 1.0 again
	fld	%st(0)            ; Duplicate 1.0
	fucomp	%st(2)            ; Compare 1.0 with dot product (unordered)
	fnstsw	%ax              ; Store FPU status word
	sahf                      ; Transfer to CPU flags
	ja	L35               ; Jump if 1.0 > dot (dot product is valid)
	
	; dot >= 1.0, clamp to 1.0
	fstp	%st(1)            ; Pop the duplicated 1.0
	jmp	L33               ; Jump to acos calculation
	
L36:   ; dot <= -1.0, clamp to -1.0
	fstp	%st(1)            ; Pop the current value
	
L33:   ; Continue with clamped value
L26:   ; Calculate acos and final distance
	fstpt	(%esp)            ; Store clamped dot product as parameter
	call	_acosl            ; Call acos function to get angle in radians
	fmuls	LC3               ; Multiply by R_EARTH constant to get distance
	addl	$156, %esp        ; Deallocate local stack space
	ret                       ; Return with distance in st(0)
	
L35:   ; Handle case where dot might be < -1.0
	fstp	%st(0)            ; Pop the 1.0
	fld1                      ; Load 1.0
	fchs                      ; Change sign to get -1.0
	fld	%st(0)            ; Duplicate -1.0
	fxch	%st(2)            ; Exchange with dot product
	fucom	%st(2)            ; Compare dot with -1.0
	fnstsw	%ax              ; Store FPU status word
	fstp	%st(2)            ; Pop one of the values
	sahf                      ; Transfer to CPU flags
	jbe	L36               ; Jump if dot <= -1.0
	
	; dot > -1.0, use original dot product
	fstp	%st(0)            ; Pop -1.0
	jmp	L26               ; Jump to acos calculation

;===============================================================================
; SECTION 5: GREAT CIRCLE POINT CALCULATION
;===============================================================================

	.p2align 4,,15
	.globl	__Z30point_at_angle_on_great_circleRK5PointS1_e
	.def	__Z30point_at_angle_on_great_circleRK5PointS1_e;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: Point point_at_angle_on_great_circle(const Point& u, const Point& v, long double angle_from_u)
; Returns point P on great circle through u and v at angular distance angle_from_u from u
; Algorithm: P = u_norm * cos(angle_from_u) + v_ortho_norm * sin(angle_from_u)
; where v_ortho_norm = normalize(v_norm - u_norm * dot(u_norm, v_norm))
__Z30point_at_angle_on_great_circleRK5PointS1_e:
	pushl	%esi              ; Save ESI register
	pushl	%ebx              ; Save EBX register  
	subl	$340, %esp        ; Allocate 340 bytes of local stack space
	
	; Load parameters
	movl	356(%esp), %esi   ; Load address of point u
	movl	352(%esp), %ebx   ; Load address of result point
	movl	360(%esp), %edx   ; Load address of point v
	
	; Normalize point u
	leal	144(%esp), %eax   ; Address for normalized u
	movl	%eax, (%esp)      ; Push result address
	movl	%esi, 4(%esp)     ; Push u address
	call	__Z9normalizeRK5Point ; Call normalize(u)
	
	; Store normalized u components in local variables  
	fldt	144(%esp)         ; Load u_norm.x
	fstpt	32(%esp)          ; Store u_norm.x
	fldt	156(%esp)         ; Load u_norm.y
	fstpt	16(%esp)          ; Store u_norm.y
	fldt	168(%esp)         ; Load u_norm.z
	fstpt	48(%esp)          ; Store u_norm.z
	
	; Normalize point v
	leal	192(%esp), %eax   ; Address for normalized v
	movl	%eax, (%esp)      ; Push result address
	movl	%edx, 4(%esp)     ; Push v address
	call	__Z9normalizeRK5Point ; Call normalize(v)
	
	; Calculate dot product of normalized u and v
	fldt	192(%esp)         ; Load v_norm.x
	fldt	204(%esp)         ; Load v_norm.y
	fldt	216(%esp)         ; Load v_norm.z
	fldt	32(%esp)          ; Load u_norm.x
	fmul	%st(3), %st       ; u_norm.x * v_norm.x
	fldt	16(%esp)          ; Load u_norm.y
	fmul	%st(3), %st       ; u_norm.y * v_norm.y
	faddp	%st, %st(1)       ; Add x and y products
	fldt	48(%esp)          ; Load u_norm.z
	fmul	%st(2), %st       ; u_norm.z * v_norm.z
	faddp	%st, %st(1)       ; Add z product to get dot(u_norm, v_norm)
	
	; Store dot product and check for degeneracy
	fld	%st(0)            ; Duplicate dot product
	fstpt	240(%esp)         ; Store dot product
	
	; Check if u and v are nearly identical (angle_uv < EPS)
	fld1                      ; Load 1.0
	fstpt	128(%esp)         ; Store 1.0
	fldt	128(%esp)         ; Load 1.0 again
	fld	%st(0)            ; Duplicate 1.0
	fucomp	%st(2)            ; Compare 1.0 with dot product
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	ja	L51               ; Jump if dot < 1.0 (points are different)
	
	; Points are nearly identical, return u
	fxch	%st(3)            ; Exchange stack elements
	
L38:   ; Store result and clean up
	fstpt	112(%esp)         ; Store component
	fstpt	96(%esp)          ; Store component
	fstpt	80(%esp)          ; Store component
	; ... (additional complex calculations for orthogonal basis and final point)
	
	; Function epilogue
	addl	$340, %esp        ; Deallocate local stack space
	popl	%ebx              ; Restore EBX register
	popl	%esi              ; Restore ESI register
	ret
	
L51:   ; Handle case where points are different
	; ... (complex calculations for creating orthogonal basis and computing final point)
	jmp	L38               ; Jump to result storage

;===============================================================================
; SECTION 6: ARC ANALYSIS AND SAFETY CHECKING
;===============================================================================

	.p2align 4,,15
	.globl	__Z9is_on_arcRK5PointS1_S1_
	.def	__Z9is_on_arcRK5PointS1_S1_;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: bool is_on_arc(const Point& u, const Point& v, const Point& p)
; Checks if point p lies on the great circle arc from u to v
; Algorithm: Check if dist(u,p) + dist(p,v) ≈ dist(u,v) within EPS tolerance
; Returns 1 if point is on arc, 0 otherwise
__Z9is_on_arcRK5PointS1_S1_:
	pushl	%edi              ; Save EDI register
	pushl	%esi              ; Save ESI register
	pushl	%ebx              ; Save EBX register
	subl	$48, %esp         ; Allocate 48 bytes of local stack space
	
	; Load function parameters
	movl	64(%esp), %edi    ; Load address of point u
	movl	68(%esp), %esi    ; Load address of point v
	movl	72(%esp), %ebx    ; Load address of point p
	
	; C++ EQUIVALENT: long double dist_uv = dist_xyz(u, v);
	movl	%esi, 4(%esp)     ; Push v address as parameter 2
	movl	%edi, (%esp)      ; Push u address as parameter 1
	call	__Z8dist_xyzRK5PointS1_ ; Call dist_xyz(u, v)
	fstpt	32(%esp)          ; Store dist_uv in local variable
	
	; C++ EQUIVALENT: long double dist_up = dist_xyz(u, p);
	movl	%ebx, 4(%esp)     ; Push p address as parameter 2
	movl	%edi, (%esp)      ; Push u address as parameter 1
	call	__Z8dist_xyzRK5PointS1_ ; Call dist_xyz(u, p)
	fstpt	16(%esp)          ; Store dist_up in local variable
	
	; C++ EQUIVALENT: long double dist_pv = dist_xyz(p, v);
	movl	%esi, 4(%esp)     ; Push v address as parameter 2
	movl	%ebx, (%esp)      ; Push p address as parameter 1
	call	__Z8dist_xyzRK5PointS1_ ; Call dist_xyz(p, v)
	
	; C++ EQUIVALENT: return abs(dist_up + dist_pv - dist_uv) <= EPS;
	fldt	16(%esp)          ; Load dist_up
	faddp	%st, %st(1)       ; Add dist_up + dist_pv
	fldt	32(%esp)          ; Load dist_uv
	fsubrp	%st, %st(1)       ; Subtract: (dist_up + dist_pv) - dist_uv
	fabs                      ; Take absolute value
	fldt	LC5               ; Load EPS constant
	fucompp               ; Compare |difference| with EPS and pop both
	fnstsw	%ax               ; Store FPU status word in AX
	sahf                      ; Transfer AH to CPU flags
	seta	%al               ; Set AL = 1 if |difference| > EPS, 0 otherwise
	
	; Function epilogue
	addl	$48, %esp         ; Deallocate local stack space
	popl	%ebx              ; Restore EBX register
	popl	%esi              ; Restore ESI register
	popl	%edi              ; Restore EDI register
	ret                       ; Return (AL contains result: 0=on arc, 1=not on arc)

;===============================================================================
; SECTION 7: STL CONTAINER OPERATIONS
;===============================================================================

; The following functions implement STL container operations for:
; - std::vector<Point> for storing intersection points
; - std::set<Point, Point::Compare> for unique vertex storage
; - std::map<Point, int, Point::Compare> for vertex indexing
; - std::vector<std::vector<long double>> for adjacency matrices

; C++ EQUIVALENT: std::vector<Point>::push_back() operations
; These are heavily optimized template instantiations for Point storage

	.section	.text$_ZNSt6vectorI5PointSaIS0_EE12emplace_backIJS0_EEEvDpOT_,"x"
	.linkonce discard
	.align 2
	.p2align 4,,15
	.globl	__ZNSt6vectorI5PointSaIS0_EE12emplace_backIJS0_EEEvDpOT_
	.def	__ZNSt6vectorI5PointSaIS0_EE12emplace_backIJS0_EEEvDpOT_;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: std::vector<Point>::emplace_back(Point&& point)
; Fast path for adding Point to vector when capacity is available
__ZNSt6vectorI5PointSaIS0_EE12emplace_backIJS0_EEEvDpOT_:
	movl	4(%ecx), %eax     ; Load vector.end() pointer
	cmpl	8(%ecx), %eax     ; Compare with vector.capacity_end()
	pushl	%ebx              ; Save EBX register
	movl	8(%esp), %edx     ; Load address of Point to add
	je	L176                  ; Jump if no space available (need reallocation)
	
	; Fast path: Copy Point data directly to end of vector
	testl	%eax, %eax        ; Check if end pointer is valid
	je	L177                  ; Jump if null pointer
	
	; Copy all 36 bytes of Point structure (3 long doubles = 3 * 12 bytes)
	movl	(%edx), %ebx      ; Copy bytes 0-3 of Point
	movl	%ebx, (%eax)      ; Store to vector end
	movl	4(%edx), %ebx     ; Copy bytes 4-7 of Point
	movl	%ebx, 4(%eax)     ; Store to vector end
	movl	8(%edx), %ebx     ; Copy bytes 8-11 of Point
	movl	%ebx, 8(%eax)     ; Store to vector end
	movl	12(%edx), %ebx    ; Copy bytes 12-15 of Point
	movl	%ebx, 12(%eax)    ; Store to vector end
	movl	16(%edx), %ebx    ; Copy bytes 16-19 of Point
	movl	%ebx, 16(%eax)    ; Store to vector end
	movl	20(%edx), %ebx    ; Copy bytes 20-23 of Point
	movl	%ebx, 20(%eax)    ; Store to vector end
	movl	24(%edx), %ebx    ; Copy bytes 24-27 of Point
	movl	%ebx, 24(%eax)    ; Store to vector end
	movl	28(%edx), %ebx    ; Copy bytes 28-31 of Point
	movl	%ebx, 28(%eax)    ; Store to vector end
	movl	32(%edx), %edx    ; Copy bytes 32-35 of Point
	movl	%edx, 32(%eax)    ; Store to vector end
	
L177:
	addl	$36, %eax         ; Add sizeof(Point) to end pointer
	movl	%eax, 4(%ecx)     ; Store new end pointer
	popl	%ebx              ; Restore EBX register
	ret	$4                    ; Return with stack cleanup
	
	.p2align 4,,10        ; Align for performance
L176:
	; Slow path: Need to reallocate vector storage
	movl	%edx, 8(%esp)     ; Pass Point address to reallocation function
	popl	%ebx              ; Restore EBX register
	jmp	__ZNSt6vectorI5PointSaIS0_EE19_M_emplace_back_auxIJS0_EEEvDpOT_

; C++ EQUIVALENT: std::set<Point>::insert() operations  
; Uses red-black tree implementation for efficient sorted storage

	.section	.text$_ZNSt8_Rb_treeI5PointS0_St9_IdentityIS0_ENS0_7CompareESaIS0_EE8_M_eraseEPSt13_Rb_tree_nodeIS0_E,"x"
	.linkonce discard
	.align 2
	.p2align 4,,15
	.globl	__ZNSt8_Rb_treeI5PointS0_St9_IdentityIS0_ENS0_7CompareESaIS0_EE8_M_eraseEPSt13_Rb_tree_nodeIS0_E
	.def	__ZNSt8_Rb_treeI5PointS0_St9_IdentityIS0_ENS0_7CompareESaIS0_EE8_M_eraseEPSt13_Rb_tree_nodeIS0_E;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: std::_Rb_tree<Point>::_M_erase(node*)
; Recursive function to delete red-black tree subtree
__ZNSt8_Rb_treeI5PointS0_St9_IdentityIS0_ENS0_7CompareESaIS0_EE8_M_eraseEPSt13_Rb_tree_nodeIS0_E:
	pushl	%edi              ; Save EDI register
	pushl	%esi              ; Save ESI register
	pushl	%ebx              ; Save EBX register
	subl	$16, %esp         ; Allocate 16 bytes of local stack space
	
	movl	32(%esp), %ebx    ; Load node pointer from parameter
	testl	%ebx, %ebx        ; Check if node is null
	je	L141                  ; Jump if null (base case)
	
	movl	%ecx, %edi        ; Save tree pointer (this)
	
	.p2align 4,,10        ; Align for performance
L147:
	; Recursively delete right subtree
	movl	12(%ebx), %eax    ; Load node->right pointer
	movl	%edi, %ecx        ; Restore tree pointer
	movl	%eax, (%esp)      ; Push right child as parameter
	call	__ZNSt8_Rb_treeI5PointS0_St9_IdentityIS0_ENS0_7CompareESaIS0_EE8_M_eraseEPSt13_Rb_tree_nodeIS0_E
	
	; Save left child and delete current node
	movl	8(%ebx), %esi     ; Load node->left pointer
	subl	$4, %esp          ; Adjust stack after call
	movl	%ebx, (%esp)      ; Push node pointer as parameter
	call	__ZdlPv               ; Call operator delete
	
	; Continue with left subtree
	testl	%esi, %esi        ; Check if left child exists
	movl	%esi, %ebx        ; Move left child to current node
	jne	L147                  ; Jump if left child exists
	
L141:
	addl	$16, %esp         ; Deallocate local stack space
	popl	%ebx              ; Restore EBX register
	popl	%esi              ; Restore ESI register
	popl	%edi              ; Restore EDI register
	ret	$4                    ; Return with stack cleanup

; C++ EQUIVALENT: std::map<Point, int>::operator[]() operations
; Uses red-black tree for efficient key-value mapping

	.section	.text$_ZNSt8_Rb_treeI5PointSt4pairIKS0_iESt10_Select1stIS3_ENS0_7CompareESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E,"x"
	.linkonce discard
	.align 2
	.p2align 4,,15
	.globl	__ZNSt8_Rb_treeI5PointSt4pairIKS0_iESt10_Select1stIS3_ENS0_7CompareESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E
	.def	__ZNSt8_Rb_treeI5PointSt4pairIKS0_iESt10_Select1stIS3_ENS0_7CompareESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E;	.scl	2;	.type	32;	.endef

; C++ EQUIVALENT: std::_Rb_tree<Point, std::pair<const Point, int>>::_M_erase(node*)
; Recursive function to delete red-black tree subtree for map<Point, int>
__ZNSt8_Rb_treeI5PointSt4pairIKS0_iESt10_Select1stIS3_ENS0_7CompareESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E:
	pushl	%edi              ; Save EDI register
	pushl	%esi              ; Save ESI register
	pushl	%ebx              ; Save EBX register
	subl	$16, %esp         ; Allocate 16 bytes of local stack space
	
	movl	32(%esp), %ebx    ; Load node pointer from parameter
	testl	%ebx, %ebx        ; Check if node is null
	je	L141                  ; Jump if null (base case)
	
	movl	%ecx, %edi        ; Save tree pointer (this)
	
	.p2align 4,,10        ; Align for performance
L147:
	; Recursively delete right subtree
	movl	12(%ebx), %eax    ; Load node->right pointer
	movl	%edi, %ecx        ; Restore tree pointer
	movl	%eax, (%esp)      ; Push right child as parameter
	call	__ZNSt8_Rb_treeI5PointSt4pairIKS0_iESt10_Select1stIS3_ENS0_7CompareESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E
	
	; Save left child and delete current node
	movl	8(%ebx), %esi     ; Load node->left pointer
	subl	$4, %esp          ; Adjust stack after call
	movl	%ebx, (%esp)      ; Push node pointer as parameter
	call	__ZdlPv               ; Call operator delete
	
	; Continue with left subtree
	testl	%esi, %esi        ; Check if left child exists
	movl	%esi, %ebx        ; Move left child to current node
	jne	L147                  ; Jump if left child exists
	
L141:
	addl	$16, %esp         ; Deallocate local stack space
	popl	%ebx              ; Restore EBX register
	popl	%esi              ; Restore ESI register
	popl	%edi              ; Restore EDI register
	ret	$4                    ; Return with stack cleanup

;===============================================================================
; SECTION 8: SMALL CIRCLE INTERSECTIONS
;===============================================================================

; C++ EQUIVALENT: vector<Point> get_small_circle_intersections(const Point& center1, const Point& center2, long double R_sphere)
; This function finds intersection points of two small circles (R-spheres) on Earth's surface
; Mathematical algorithm involves:
; 1. Computing angular distance between sphere centers
; 2. Checking if spheres intersect (distance constraints)
; 3. Finding intersection points using spherical trigonometry
; 4. Converting back to Cartesian coordinates

	.p2align 4,,15
	.globl	__Z30get_small_circle_intersectionsRK5PointS1_e
	.def	__Z30get_small_circle_intersectionsRK5PointS1_e;	.scl	2;	.type	32;	.endef

__Z30get_small_circle_intersectionsRK5PointS1_e:
	pushl	%ebp              ; Save EBP register
	pushl	%edi              ; Save EDI register
	pushl	%esi              ; Save ESI register
	pushl	%ebx              ; Save EBX register
	subl	$476, %esp        ; Allocate 476 bytes of local stack space
	
	; Load function parameters
	movl	500(%esp), %eax   ; Load address of center1
	leal	176(%esp), %edi   ; Load address for normalized center1 (c1_norm)
	movl	496(%esp), %ebx   ; Load address of result vector
	leal	224(%esp), %esi   ; Load address for normalized center2 (c2_norm)
	
	; ========================================================================
	; STEP 1: Computing angular distance between sphere centers
	; ========================================================================
	
	; C++ EQUIVALENT: Point c1_norm = normalize(center1);
	movl	%edi, (%esp)      ; Push result address
	movl	%eax, 4(%esp)     ; Push center1 address  
	call	__Z9normalizeRK5Point ; Call normalize(center1)
	
	; C++ EQUIVALENT: Point c2_norm = normalize(center2);
	movl	504(%esp), %eax   ; Load address of center2
	movl	%esi, (%esp)      ; Push result address
	movl	%eax, 4(%esp)     ; Push center2 address
	call	__Z9normalizeRK5Point ; Call normalize(center2)
	
	; C++ EQUIVALENT: long double dot_product = dot(c1_norm, c2_norm);
	movl	%edi, (%esp)      ; Push c1_norm address
	movl	%esi, 4(%esp)     ; Push c2_norm address
	call	__Z3dotRK5PointS1_ ; Call dot(c1_norm, c2_norm)
	fstpt	32(%esp)          ; Store dot_product on stack
	
	; C++ EQUIVALENT: Clamp dot_product to [-1.0, 1.0] to avoid numerical errors
	fldt	32(%esp)          ; Load dot_product
	fldt	LC9               ; Load -1.0 (lower bound)
	fxch	%st(1)            ; Swap stack elements
	fucom	%st(1)            ; Compare dot_product with -1.0
	fnstsw	%ax               ; Store FPU status
	sahf                      ; Load flags
	jbe	L885              ; Jump if dot_product <= -1.0
	
	fldt	LC10              ; Load 1.0 (upper bound)
	fxch	%st(1)            ; Swap stack elements
	fucom	%st(1)            ; Compare dot_product with 1.0
	fnstsw	%ax               ; Store FPU status
	sahf                      ; Load flags
	jae	L886              ; Jump if dot_product >= 1.0
	
	; dot_product is in valid range [-1.0, 1.0]
	fstp	%st(1)            ; Pop upper bound
	fstp	%st(1)            ; Pop lower bound
	jmp	L887              ; Continue to acos calculation
	
L885:
	; Clamp to -1.0
	fstp	%st(0)            ; Pop dot_product
	fstp	%st(0)            ; Pop lower bound (keep -1.0)
	jmp	L887              ; Continue to acos calculation
	
L886:
	; Clamp to 1.0
	fstp	%st(0)            ; Pop dot_product
	fxch	%st(1)            ; Swap to get 1.0 on top
	fstp	%st(1)            ; Pop lower bound (keep 1.0)
	
L887:
	; C++ EQUIVALENT: long double angular_distance = acos(clamped_dot_product);
	call	__acosl           ; Call acos function
	fstpt	48(%esp)          ; Store angular_distance on stack
	
	; ========================================================================
	; END OF STEP 1: Computing angular distance between sphere centers
	; ========================================================================

;===============================================================================
; SECTION 9: INTERVAL COVERAGE ANALYSIS
;===============================================================================

; C++ EQUIVALENT: vector<pair<long double, long double>> get_covered_intervals(...)
; Determines which portions of a great circle arc are covered by R-spheres
; Algorithm:
; 1. Find intersection points of great circle with R-sphere boundaries
; 2. Parameterize arc from 0 to 1 based on distance
; 3. Test intervals between critical points for coverage
; 4. Return list of covered intervals

; C++ EQUIVALENT: vector<pair<long double, long double>> merge_intervals(...)
; Merges overlapping intervals to create consolidated coverage map
; Uses standard interval merging algorithm with tolerance handling

; C++ EQUIVALENT: bool is_arc_safe(const Point& u, const Point& v, ...)
; Checks if entire arc is safe by verifying complete coverage
; Algorithm:
; 1. Get all covered intervals for the arc
; 2. Merge overlapping intervals
; 3. Check if merged intervals cover [0,1] completely

;===============================================================================
; SECTION 10: FLOYD-WARSHALL ALGORITHM IMPLEMENTATION
;===============================================================================

; The assembly code implements the Floyd-Warshall all-pairs shortest path algorithm
; C++ EQUIVALENT:
; for (int k = 0; k < V; ++k) {
;     for (int i = 0; i < V; ++i) {
;         for (int j = 0; j < V; ++j) {
;             if (adj[i][k] != INF && adj[k][j] != INF) {
;                 adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);
;             }
;         }
;     }
; }

; FLOYD-WARSHALL INITIALIZATION: Set up adjacency matrix with direct distances
L988:
	testl	%ebx, %ebx        ; Check if vertex count > 0
	jle	L1033             ; Skip if no vertices
	leal	(%ebx,%ebx,2), %edx ; Calculate 3 * vertex_count
	movl	-168(%ebp), %ecx  ; Load adjacency matrix pointer
	fldz                   ; Load 0.0 onto FPU stack
	xorl	%edi, %edi        ; Clear counter
	sall	$2, %edx          ; Calculate matrix size = 3 * V * 4 bytes
	
L1035:
	; INITIALIZE DIAGONAL ELEMENTS: Set dist[i][i] = 0.0
	movl	(%ecx,%edi), %eax ; Load matrix row pointer
	fstpt	(%eax,%edi)       ; Store 0.0 at matrix[i][i]
	fldt	(%eax,%edi)       ; Reload for next iteration
	addl	$12, %edi         ; Move to next diagonal element
	cmpl	%edi, %edx        ; Check if all diagonal elements set
	jne	L1035             ; Continue if not done
	fstp	%st(0)            ; Pop 0.0 from FPU stack
	
	; DIRECT DISTANCE CALCULATION: Fill matrix with direct arc distances
	movl	-180(%ebp), %eax  ; Load vertex array pointer
	movl	$12, -164(%ebp)   ; Initialize offset counter
	movl	%edi, -160(%ebp)  ; Store matrix size
	movl	-168(%ebp), %esi  ; Load matrix pointer
	addl	$36, %eax         ; Move to second vertex
	movl	%eax, -208(%ebp)  ; Store current vertex pointer
	movl	-164(%ebp), %eax  ; Load offset
	cmpl	%eax, -160(%ebp)  ; Compare offset with matrix size
	je	L1038             ; Jump if done with initialization
	
L1244:
	; NESTED LOOP: Calculate distances between all vertex pairs
	movl	-208(%ebp), %edi  ; Load current vertex j
	leal	-36(%edi), %ebx   ; Calculate previous vertex i
	movl	%ebx, -156(%ebp)  ; Store vertex i pointer
	leal	-12(%eax), %ebx   ; Calculate matrix offset
	movl	%ebx, -172(%ebp)  ; Store offset
	movl	%eax, %ebx        ; Copy offset to EBX
	
	.p2align 4,,10        ; Align for performance
L1046:
	; DISTANCE CALCULATION: dist_xyz(vertex_i, vertex_j)
	movl	-156(%ebp), %eax  ; Load vertex i
	movl	%edi, 4(%esp)     ; Push vertex j as parameter
	movl	%eax, (%esp)      ; Push vertex i as parameter
	call	__Z8dist_xyzRK5PointS1_ ; Call great circle distance function
	
	; EPSILON COMPARISON: Check if distance is valid (> EPS)
	fldt	LC5               ; Load EPS constant
	fucomp	%st(1)            ; Compare EPS with distance
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	ja	L1045             ; Jump if distance > EPS (valid distance)
	
	; STORE TEMPORARY DISTANCE: Save distance for arc safety check
	fstpt	-200(%ebp)        ; Store distance temporarily
	
	; ARC SAFETY CHECK: is_arc_safe(vertex_i, vertex_j, airports, R)
	leal	-100(%ebp), %eax  ; Load address for result
	movl	%edi, 4(%esp)     ; Push vertex j
	movl	%eax, 8(%esp)     ; Push airports array
	movl	-156(%ebp), %eax  ; Load vertex i
	movl	%eax, (%esp)      ; Push vertex i
	fldt	-136(%ebp)        ; Load R (fuel range)
	fstpt	12(%esp)          ; Push R as parameter
	call	__Z11is_arc_safeRK5PointS1_RKSt6vectorIS_SaIS_EEe
	testb	%al, %al          ; Test if arc is safe
	fldt	-200(%ebp)        ; Reload distance
	je	L1251             ; Jump if arc is NOT safe
	
L1045:
	; STORE VALID DISTANCE: Add distance to adjacency matrix
	movl	-164(%ebp), %ecx  ; Load matrix row offset
	movl	-172(%ebp), %edx  ; Load matrix column offset
	movl	-12(%esi,%ecx), %eax ; Load matrix[i] row pointer
	movl	(%esi,%ebx), %ecx ; Load matrix[j] row pointer
	addl	%ebx, %eax        ; Calculate matrix[i][j] address
	fld	%st(0)            ; Duplicate distance on FPU stack
	fstpt	(%ecx,%edx)       ; Store distance at matrix[j][i]
	fstpt	(%eax)            ; Store distance at matrix[i][j]
	jmp	L1041             ; Jump to next iteration
	
L1251:
	; INVALID ARC: Arc is not safe, don't store distance (keep as infinity)
	fstp	%st(0)            ; Pop invalid distance from FPU stack
	
L1041:
	; INNER LOOP INCREMENT: Move to next vertex pair
	addl	$36, %edi         ; Move to next vertex j
	addl	$12, %ebx         ; Move to next matrix column
	cmpl	%ebx, -160(%ebp)  ; Check if finished with current row
	jne	L1046             ; Continue inner loop if not done
	
	; OUTER LOOP INCREMENT: Move to next row
	addl	$12, -164(%ebp)   ; Move to next matrix row
	addl	$36, -208(%ebp)   ; Move to next vertex i
	movl	-164(%ebp), %eax  ; Load new row offset
	cmpl	%eax, -160(%ebp)  ; Check if finished with all rows
	jne	L1244             ; Continue outer loop if not done
	
L1038:
	; FLOYD-WARSHALL MAIN ALGORITHM: Triple nested loop for shortest paths
	; INITIALIZATION: Set up for k-i-j nested loops
	fldt	LC17              ; Load -INF constant (large negative number)
	movl	-160(%ebp), %edi  ; Load matrix size
	movl	-168(%ebp), %eax  ; Load matrix pointer
	leal	(%eax,%edi), %esi ; Calculate matrix end pointer
	movl	%edi, -156(%ebp)  ; Store matrix size
	movl	%eax, %edi        ; Move matrix pointer to EDI
	movl	%esi, -164(%ebp)  ; Store matrix end pointer
	xorl	%esi, %esi        ; Clear k counter (outer loop)
	
L1052:
	; FLOYD-WARSHALL OUTER LOOP: for (k = 0; k < V; k++)
	movl	%edi, -160(%ebp)  ; Store current matrix row pointer
	
	.p2align 4,,10        ; Align for performance
L1051:
	; FLOYD-WARSHALL MIDDLE LOOP: for (i = 0; i < V; i++)
	movl	-160(%ebp), %eax  ; Load matrix row i pointer
	xorl	%edx, %edx        ; Clear j counter (inner loop)
	movl	(%eax), %ecx      ; Load matrix[i] row pointer
	leal	(%ecx,%esi), %ebx ; Calculate &matrix[i][k] address
	
	.p2align 4,,10        ; Align for performance
L1050:
	; FLOYD-WARSHALL INNER LOOP: for (j = 0; j < V; j++)
	; ALGORITHM: if (dist[i][k] + dist[k][j] < dist[i][j]) dist[i][j] = dist[i][k] + dist[k][j]
	
	; CHECK matrix[i][j] != INF
	fldt	(%ebx)            ; Load matrix[i][k]
	fucom	%st(1)            ; Compare with -INF
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	ja	L1252             ; Jump if matrix[i][k] == INF (skip this triplet)
	
	; CHECK matrix[k][j] != INF
	movl	(%edi,%esi), %eax ; Load matrix[k] row pointer
	fldt	(%eax,%edx)       ; Load matrix[k][j]
	fucom	%st(2)            ; Compare with -INF
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	ja	L1253             ; Jump if matrix[k][j] == INF (skip this triplet)
	
	; CALCULATE matrix[i][k] + matrix[k][j]
	faddp	%st, %st(1)       ; Add: matrix[i][k] + matrix[k][j]
	fldt	(%ecx,%edx)       ; Load current matrix[i][j]
	fucom	%st(1)            ; Compare matrix[i][j] with (matrix[i][k] + matrix[k][j])
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	jbe	L1254             ; Jump if current distance <= new distance
	
	; UPDATE matrix[i][j]: Found shorter path through k
	fstp	%st(0)            ; Pop old matrix[i][j]
	jmp	L1104             ; Jump to store new distance
	
	.p2align 4,,10        ; Align for performance
L1254:
	; KEEP OLD DISTANCE: Current distance is shorter
	fstp	%st(1)            ; Pop the sum, keep old distance
	
L1104:
	; STORE RESULT: Update matrix[i][j] with minimum distance
	fstpt	(%ecx,%edx)       ; Store minimum distance at matrix[i][j]
	jmp	L1048             ; Jump to next j iteration
	
	.p2align 4,,10        ; Align for performance
L1252:
	; SKIP: matrix[i][k] == INF, no path through k
	fstp	%st(0)            ; Pop matrix[i][k]
	jmp	L1048             ; Jump to next j iteration
	
	.p2align 4,,10        ; Align for performance
L1253:
	; SKIP: matrix[k][j] == INF, no path through k
	fstp	%st(0)            ; Pop matrix[k][j]
	fstp	%st(0)            ; Pop matrix[i][k]
	
L1048:
	; INNER LOOP INCREMENT: j++
	addl	$12, %edx         ; Move to next column (j++)
	cmpl	%edx, -156(%ebp)  ; Check if j < V
	jne	L1050             ; Continue inner loop if j < V
	
	; MIDDLE LOOP INCREMENT: i++
	addl	$12, -160(%ebp)   ; Move to next row (i++)
	movl	-160(%ebp), %eax  ; Load new row pointer
	cmpl	%eax, -164(%ebp)  ; Check if i < V
	jne	L1051             ; Continue middle loop if i < V
	
	; OUTER LOOP INCREMENT: k++
	addl	$12, %esi         ; Move to next k (k++)
	cmpl	%esi, -156(%ebp)  ; Check if k < V
	jne	L1052             ; Continue outer loop if k < V
	
	; FLOYD-WARSHALL COMPLETE: All-pairs shortest paths computed
	fstp	%st(0)            ; Pop -INF constant from FPU stack

;===============================================================================
; SECTION 11: QUERY PROCESSING AND OUTPUT
;===============================================================================

L1033:
	; QUERY INPUT: Read number of queries Q
	leal	-148(%ebp), %eax  ; Load address of Q variable
	movl	$__ZSt3cin, %ecx  ; Load cin object
	movl	%eax, (%esp)      ; Push Q address
	call	__ZNSirsERi       ; Call cin >> Q
	
	; OUTPUT TEST CASE HEADER: "Case #N:"
	movl	-204(%ebp), %edi  ; Load current case number
	subl	$4, %esp          ; Adjust stack
	movl	$5, 8(%esp)       ; String length for "Case "
	movl	$LC14, 4(%esp)    ; Push "Case " string literal
	movl	$__ZSt4cout, (%esp) ; Push cout object
	movl	%edi, %eax        ; Copy case number
	addl	$1, %eax          ; Increment case number for next iteration
	movl	%eax, -204(%ebp)  ; Store incremented case number
	call	__ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i ; Print "Case "
	
	; OUTPUT CASE NUMBER
	movl	$__ZSt4cout, %ecx ; Load cout object
	movl	%edi, (%esp)      ; Push case number
	call	__ZNSolsEi        ; Call cout << case_number
	subl	$4, %esp          ; Adjust stack
	movl	%eax, %ebx        ; Store cout result
	
	; OUTPUT COLON AND NEWLINE
	movl	$1, 8(%esp)       ; String length for ":"
	movl	$LC15, 4(%esp)    ; Push ":" string literal
	movl	%eax, (%esp)      ; Push cout object
	call	__ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i ; Print ":"
	
	; FLUSH OUTPUT BUFFER
	movl	(%ebx), %eax      ; Load cout vtable
	movl	-12(%eax), %eax   ; Get vtable offset
	movl	124(%ebx,%eax), %esi ; Load ctype facet
	testl	%esi, %esi        ; Check if facet exists
	je	L1036             ; Jump to error if null
	cmpb	$0, 28(%esi)      ; Check if facet is initialized
	je	L1053             ; Jump to initialization if needed
	movsbl	39(%esi), %eax   ; Load newline character
	
L1054:
	movl	%ebx, %ecx        ; Load cout object
	movl	%eax, (%esp)      ; Push newline character
	call	__ZNSo3putEc      ; Call cout.put('\n')
	subl	$4, %esp          ; Adjust stack
	movl	%eax, %ecx        ; Load cout result
	call	__ZNSo5flushEv    ; Call cout.flush()
	
	; QUERY PROCESSING LOOP: Process each query
	movl	-148(%ebp), %ebx  ; Load Q (number of queries)
	testl	%ebx, %ebx        ; Check if Q > 0
	jle	L1092             ; Skip if no queries
	movl	$0, -200(%ebp)    ; Initialize query counter
	
L1093:
	; QUERY INPUT: Read source, destination, and additional_fuel
	leal	-144(%ebp), %eax  ; Load address of source variable
	movl	$__ZSt3cin, %ecx  ; Load cin object
	leal	-140(%ebp), %edi  ; Load address of destination variable
	movl	%eax, (%esp)      ; Push source address
	call	__ZNSirsERi       ; Call cin >> source
	subl	$4, %esp          ; Adjust stack
	movl	%eax, %ecx        ; Move result to ECX
	movl	%edi, (%esp)      ; Push destination address
	call	__ZNSirsERi       ; Call cin >> destination
	subl	$4, %esp          ; Adjust stack
	movl	%eax, %ecx        ; Move result to ECX
	leal	-120(%ebp), %edi  ; Load address of additional_fuel variable
	movl	%edi, (%esp)      ; Push additional_fuel address
	call	__ZNSi10_M_extractIeEERSiRT_ ; Call cin >> additional_fuel
	
	; CONVERT TO 0-BASED INDEXING
	movl	-152(%ebp), %ebx  ; Load N (number of airports)
	subl	$4, %esp          ; Adjust stack
	subl	$1, -144(%ebp)    ; source = source - 1 (0-based)
	subl	$1, -140(%ebp)    ; destination = destination - 1 (0-based)
	testl	%ebx, %ebx        ; Check if N > 0
	je	L1245             ; Jump if no airports
	
	; ALLOCATE TEMPORARY DISTANCE MATRIX: For modified Floyd-Warshall with additional fuel
	cmpl	$357913941, %ebx  ; Check for overflow
	ja	L983              ; Jump to error if too large
	leal	(%ebx,%ebx,2), %edi ; Calculate 3 * N
	leal	0(,%edi,4), %eax  ; Calculate 3 * N * 4 bytes
	movl	%eax, (%esp)      ; Push size
	movl	%eax, -156(%ebp)  ; Store size
	call	__Znwj            ; Allocate memory
	flds	LC13              ; Load infinity constant
	movl	%eax, -164(%ebp)  ; Store matrix pointer
	
L1060:
	; INITIALIZE TEMP MATRIX: Set all distances to infinity
	fstpt	(%eax)            ; Store infinity at matrix[i]
	fldt	(%eax)            ; Reload for next iteration
	addl	$12, %eax         ; Move to next element
	subl	$1, %ebx          ; Decrement counter
	jne	L1060             ; Continue until all initialized
	fstp	%st(0)            ; Pop infinity from FPU stack
	
	; COPY ORIGINAL MATRIX: Copy shortest paths to temporary matrix
	movl	-152(%ebp), %eax  ; Load N
	testl	%eax, %eax        ; Check if N > 0
	je	L1118             ; Skip if no airports
	cmpl	$357913941, %eax  ; Check for overflow
	ja	L983              ; Jump to error if too large
	leal	(%eax,%eax,2), %esi ; Calculate 3 * N
	sall	$2, %esi          ; Calculate 3 * N * 4 bytes
	movl	%esi, (%esp)      ; Push size
	call	__Znwj            ; Allocate memory
	movl	-156(%ebp), %ecx  ; Load size
	movl	%eax, %edi        ; Store new matrix pointer
	movl	%edi, -208(%ebp)  ; Store matrix pointer
	movl	%ecx, %eax        ; Copy size
	sarl	$2, %eax          ; Convert to element count
	imull	$-1431655765, %eax, %ebx ; Calculate actual count
	leal	(%edi,%esi), %eax ; Calculate end address
	movl	%edi, %esi        ; Copy matrix pointer
	movl	%eax, -156(%ebp)  ; Store end address
	movl	%ebx, %edi        ; Store count
	movl	%ecx, %ebx        ; Copy size
	
L1066:
	; MATRIX COPY LOOP: Copy each row of the distance matrix
	testl	%esi, %esi        ; Check if valid pointer
	je	L1062             ; Skip if null
	xorl	%eax, %eax        ; Clear pointer
	testl	%edi, %edi        ; Check if count > 0
	movl	$0, (%esi)        ; Initialize row pointer
	movl	$0, 4(%esi)       ; Initialize row end
	movl	$0, 8(%esi)       ; Initialize row capacity
	je	L1064             ; Skip if no elements
	cmpl	$357913941, %edi  ; Check for overflow
	ja	L983              ; Jump to error if too large
	movl	%ebx, (%esp)      ; Push size
	call	__Znwj            ; Allocate row memory
	
L1064:
	; SETUP ROW POINTERS
	leal	(%eax,%ebx), %ecx ; Calculate row end
	testl	%edi, %edi        ; Check if count > 0
	movl	%eax, (%esi)      ; Store row begin
	movl	%eax, 4(%esi)     ; Store row current
	movl	%ecx, 8(%esi)     ; Store row end
	je	L1065             ; Skip if no elements
	
	; COPY ROW DATA: memcpy from original matrix
	movl	%ecx, -160(%ebp)  ; Store row end
	movl	-164(%ebp), %ecx  ; Load source matrix
	movl	%ebx, 8(%esp)     ; Push size
	movl	%eax, (%esp)      ; Push destination
	movl	%ecx, 4(%esp)     ; Push source
	call	_memcpy           ; Copy row data
	movl	-160(%ebp), %ecx  ; Reload row end
	
L1065:
	movl	%ecx, 4(%esi)     ; Update row current pointer
	
L1062:
	; NEXT ROW: Move to next row in matrix
	addl	$12, %esi         ; Move to next row
	cmpl	%esi, -156(%ebp)  ; Check if done
	jne	L1066             ; Continue if not done
	
	; CLEANUP ORIGINAL MATRIX
	movl	-208(%ebp), %edi  ; Load matrix pointer
	movl	%esi, -172(%ebp)  ; Store end pointer
	
L1061:
	movl	-164(%ebp), %eax  ; Load original matrix
	movl	%eax, (%esp)      ; Push matrix pointer
	call	__ZdlPv           ; Delete original matrix
	
	; MODIFIED FLOYD-WARSHALL: Add additional fuel to edges and recalculate
	movl	-152(%ebp), %esi  ; Load N
	testl	%esi, %esi        ; Check if N > 0
	jle	L1067             ; Skip if no airports
	leal	(%esi,%esi,2), %edx ; Calculate 3 * N
	fldz                   ; Load 0.0 for diagonal initialization
	xorl	%eax, %eax        ; Clear counter
	sall	$2, %edx          ; Calculate 3 * N * 4 bytes
	
L1069:
	; INITIALIZE DIAGONAL: Set distance[i][i] = 0
	movl	(%edi,%eax), %ecx ; Load matrix row
	fstpt	(%ecx,%eax)       ; Store 0.0 at diagonal
	fldt	(%ecx,%eax)       ; Reload for next iteration
	addl	$12, %eax         ; Move to next diagonal element
	cmpl	%eax, %edx        ; Check if done
	jne	L1069             ; Continue if not done
	fstp	%st(0)            ; Pop 0.0 from FPU stack
	
	; EDGE MODIFICATION: Add additional fuel to all edges
	fldt	LC5               ; Load EPS constant
	movl	%esi, -160(%ebp)  ; Store N
	movl	-176(%ebp), %ebx  ; Load vertex index mapping
	xorl	%ecx, %ecx        ; Clear i counter
	movl	-168(%ebp), %esi  ; Load original distance matrix
	movl	%eax, -156(%ebp)  ; Store matrix size
	movl	%edi, -164(%ebp)  ; Store current matrix
	movl	%edi, -208(%ebp)  ; Store matrix backup
	
L1075:
	; OUTER LOOP: For each source vertex i
	xorl	%edx, %edx        ; Clear j counter
	
	.p2align 4,,10        ; Align for performance
L1074:
	; INNER LOOP: For each destination vertex j
	cmpl	%edx, %ecx        ; Check if i == j (diagonal)
	je	L1072             ; Skip diagonal elements
	
	; CALCULATE MODIFIED DISTANCE: distance[i][j] = original[i][j] + additional_fuel
	movl	(%ebx,%ecx,4), %eax ; Load vertex index for i
	leal	(%eax,%eax,2), %edi ; Calculate 3 * i
	movl	(%ebx,%edx,4), %eax ; Load vertex index for j
	leal	(%eax,%eax,2), %eax ; Calculate 3 * j
	sall	$2, %eax          ; Calculate 3 * j * 4 bytes
	addl	(%esi,%edi,4), %eax ; Calculate &original[i][j]
	fldt	(%eax)            ; Load original distance
	fldt	-120(%ebp)        ; Load additional fuel
	fadd	%st(2), %st       ; Add: original + additional_fuel
	fucomp	%st(1)            ; Compare with EPS
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	jb	L1255             ; Jump if modified distance < EPS (invalid)
	
	; STORE MODIFIED DISTANCE: Update matrix with new distance
	movl	-164(%ebp), %edi  ; Load current matrix
	leal	(%edx,%edx,2), %eax ; Calculate 3 * j
	sall	$2, %eax          ; Calculate 3 * j * 4 bytes
	addl	(%edi), %eax      ; Calculate &modified[i][j]
	fstpt	(%eax)            ; Store modified distance
	jmp	L1072             ; Jump to next iteration
	
	.p2align 4,,10        ; Align for performance
L1255:
	; INVALID DISTANCE: Don't store invalid distance
	fstp	%st(0)            ; Pop invalid distance
	
L1072:
	; INNER LOOP INCREMENT: j++
	addl	$1, %edx          ; Increment j
	cmpl	-160(%ebp), %edx  ; Check if j < N
	jne	L1074             ; Continue if j < N
	
	cmpl	%ecx, %edx        ; Check if i < N
	jne	L1075             ; Continue if i < N
	
	; CLEANUP EPS CONSTANT: Pop EPS from FPU stack
	fstp	%st(0)            ; Pop EPS constant
	
	; SECOND FLOYD-WARSHALL: Run Floyd-Warshall on modified distances
	fldt	LC17              ; Load -INF constant
	movl	-208(%ebp), %edi  ; Load modified matrix
	movl	-156(%ebp), %eax  ; Load matrix size
	xorl	%esi, %esi        ; Clear k counter
	addl	%edi, %eax        ; Calculate matrix end
	movl	%eax, -164(%ebp)  ; Store matrix end
	
L1080:
	; FLOYD-WARSHALL OUTER LOOP: for (k = 0; k < V; k++)
	movl	%edi, -160(%ebp)  ; Store current matrix row
	
	.p2align 4,,10        ; Align for performance
L1079:
	; FLOYD-WARSHALL MIDDLE LOOP: for (i = 0; i < V; i++)
	movl	-160(%ebp), %eax  ; Load matrix row i
	xorl	%edx, %edx        ; Clear j counter
	movl	(%eax), %ecx      ; Load matrix[i] row
	leal	(%ecx,%esi), %ebx ; Calculate &matrix[i][k]
	
	.p2align 4,,10        ; Align for performance
L1078:
	; FLOYD-WARSHALL INNER LOOP: for (j = 0; j < V; j++)
	fldt	(%ebx)            ; Load matrix[i][k]
	fucom	%st(1)            ; Compare with -INF
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	ja	L1256             ; Jump if matrix[i][k] == INF
	
	; CHECK matrix[k][j] != INF
	movl	(%edi,%esi), %eax ; Load matrix[k] row
	fldt	(%eax,%edx)       ; Load matrix[k][j]
	fucom	%st(2)            ; Compare with -INF
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	ja	L1257             ; Jump if matrix[k][j] == INF
	
	; CALCULATE AND COMPARE: matrix[i][k] + matrix[k][j] vs matrix[i][j]
	faddp	%st, %st(1)       ; Add: matrix[i][k] + matrix[k][j]
	fldt	(%ecx,%edx)       ; Load matrix[i][j]
	fucom	%st(1)            ; Compare distances
	fnstsw	%ax              ; Store FPU status
	sahf                      ; Transfer to CPU flags
	jbe	L1258             ; Jump if old <= new
	
	; UPDATE: Found shorter path through k
	fstp	%st(0)            ; Pop old distance
	jmp	L1106             ; Jump to store new distance
	
	.p2align 4,,10        ; Align for performance
L1258:
	fstp	%st(1)            ; Pop new distance, keep old
	
L1106:
	fstpt	(%ecx,%edx)       ; Store minimum distance
	jmp	L1076             ; Jump to next iteration
	
	.p2align 4,,10        ; Align for performance
L1256:
	fstp	%st(0)            ; Pop invalid distance
	jmp	L1076             ; Jump to next iteration
	
	.p2align 4,,10        ; Align for performance
L1257:
	fstp	%st(0)            ; Pop matrix[k][j]
	fstp	%st(0)            ; Pop matrix[i][k]
	
L1076:
	; FLOYD-WARSHALL LOOP INCREMENTS
	addl	$12, %edx         ; j++
	cmpl	%edx, -156(%ebp)  ; Check if j < V
	jne	L1078             ; Continue inner loop
	addl	$12, -160(%ebp)   ; i++
	movl	-160(%ebp), %eax  ; Load new row pointer
	cmpl	%eax, -164(%ebp)  ; Check if i < V
	jne	L1079             ; Continue middle loop
	addl	$12, %esi         ; k++
	cmpl	%esi, -156(%ebp)  ; Check if k < V
	jne	L1080             ; Continue outer loop
	fstp	%st(0)            ; Pop -INF constant
	
L1067:
	; QUERY RESULT: Extract shortest path distance from source to destination
	movl	-144(%ebp), %eax  ; Load source index
	leal	(%eax,%eax,2), %edx ; Calculate 3 * source
	movl	-140(%ebp), %eax  ; Load destination index
	movl	(%edi,%edx,4), %ecx ; Load matrix[source] row
	leal	(%eax,%eax,2), %eax ; Calculate 3 * destination
	leal	(%ecx,%eax,4), %eax ; Calculate &matrix[source][destination]
	fldt	(%eax)            ; Load shortest distance
	fldt	LC17              ; Load -INF for comparison
	fxch	%st(1)            ; Exchange distances
	fucom	%st(1)            ; Compare distance with -INF
	fnstsw	%ax              ; Store FPU status
	fstp	%st(1)            ; Pop -INF
	sahf                      ; Transfer to CPU flags
	jbe	L1246             ; Jump if distance <= -INF (no path)
	
	; OUTPUT DISTANCE: Print the shortest distance
	fstp	%st(0)            ; Pop distance (will be output by other code)
	movl	$10, 8(%esp)      ; String length for "impossible"
	movl	$LC18, 4(%esp)    ; Push "impossible" string
	movl	$__ZSt4cout, (%esp) ; Push cout object
	call	__ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i ; Print "impossible"
	
	; OUTPUT NEWLINE: Add newline after result
	movl	__ZSt4cout, %eax  ; Load cout object
	movl	-12(%eax), %eax   ; Get vtable offset
	movl	__ZSt4cout+124(%eax), %ebx ; Load ctype facet
	testl	%ebx, %ebx        ; Check if valid
	je	L1036             ; Jump to error if null
	cmpb	$0, 28(%ebx)      ; Check if initialized
	je	L1081             ; Jump to initialization if needed
	movsbl	39(%ebx), %eax   ; Load newline character
	
L1082:
	movl	$__ZSt4cout, %ecx ; Load cout object
	movl	%eax, (%esp)      ; Push newline
	call	__ZNSo3putEc      ; Print newline
	subl	$4, %esp          ; Adjust stack
	movl	%eax, %ecx        ; Load cout result
	call	__ZNSo5flushEv    ; Flush output
	
L1083:
	; CLEANUP QUERY MATRICES: Free allocated memory for this query
	cmpl	-172(%ebp), %edi  ; Compare matrix pointers
	movl	%edi, %ebx        ; Load matrix pointer
	movl	-172(%ebp), %esi  ; Load matrix end
	je	L1090             ; Skip if no cleanup needed
	
L1179:
	; CLEANUP MATRIX ROWS: Free each row
	movl	(%ebx), %eax      ; Load row pointer
	testl	%eax, %eax        ; Check if valid
	je	L1089             ; Skip if null
	movl	%eax, (%esp)      ; Push row pointer
	call	__ZdlPv           ; Delete row
	
L1089:
	addl	$12, %ebx         ; Move to next row
	cmpl	%esi, %ebx        ; Check if done
	jne	L1179             ; Continue if more rows
	
L1090:
	; CLEANUP MATRIX STRUCTURE: Free matrix structure
	testl	%edi, %edi        ; Check if matrix exists
	je	L1088             ; Skip if null
	movl	%edi, (%esp)      ; Push matrix pointer
	call	__ZdlPv           ; Delete matrix
	
L1088:
	; NEXT QUERY: Increment query counter and continue
	addl	$1, -200(%ebp)    ; Increment query counter
	movl	-200(%ebp), %eax  ; Load query counter
	cmpl	%eax, -148(%ebp)  ; Compare with total queries
	jg	L1093             ; Continue if more queries
	
L1092:
	; CLEANUP GLOBAL STRUCTURES: Free all allocated memory
	movl	-168(%ebp), %eax  ; Load main matrix
	cmpl	%eax, -184(%ebp)  ; Compare pointers
	je	L1056             ; Skip if no cleanup needed
	movl	%eax, %ebx        ; Load matrix start
	
L1097:
	; CLEANUP MAIN MATRIX ROWS
	movl	(%ebx), %eax      ; Load row pointer
	testl	%eax, %eax        ; Check if valid
	je	L1096             ; Skip if null
	movl	%eax, (%esp)      ; Push row pointer
	call	__ZdlPv           ; Delete row
	
L1096:
	addl	$12, %ebx         ; Move to next row
	cmpl	%ebx, -184(%ebp)  ; Check if done
	jne	L1097             ; Continue if more rows
	
L1056:
	; CLEANUP MAIN STRUCTURES: Free remaining global structures
	movl	-168(%ebp), %eax  ; Load main matrix
	testl	%eax, %eax        ; Check if valid
	je	L1095             ; Skip if null
	movl	-168(%ebp), %eax  ; Load matrix pointer
	movl	%eax, (%esp)      ; Push matrix pointer
	call	__ZdlPv           ; Delete matrix
	
L1095:
	movl	-176(%ebp), %eax  ; Load vertex mapping
	testl	%eax, %eax        ; Check if valid
	je	L1098             ; Skip if null
	movl	%eax, (%esp)      ; Push mapping pointer
	call	__ZdlPv           ; Delete mapping
	
L1098:
	; CLEANUP STL CONTAINERS: Free set and map structures
	movl	-48(%ebp), %eax   ; Load vertex map root
	leal	-56(%ebp), %ecx   ; Load map address
	movl	%eax, (%esp)      ; Push root pointer
	call	__ZNSt8_Rb_treeI5PointSt4pairIKS0_iESt10_Select1stIS3_ENS0_7CompareESaIS3_EE8_M_eraseEPSt13_Rb_tree_nodeIS3_E ; Delete map tree
	movl	-180(%ebp), %eax  ; Load vertex array
	subl	$4, %esp          ; Adjust stack
	testl	%eax, %eax        ; Check if valid
	je	L1099             ; Skip if null
	movl	%eax, (%esp)      ; Push array pointer
	call	__ZdlPv           ; Delete array
	
L1099:
	movl	-80(%ebp), %eax   ; Load vertex set root
	leal	-88(%ebp), %esi   ; Load set address
	movl	%esi, %ecx        ; Load set address
	movl	%eax, (%esp)      ; Push root pointer
	call	__ZNSt8_Rb_treeI5PointS0_St9_IdentityIS0_ENS0_7CompareESaIS0_EE8_M_eraseEPSt13_Rb_tree_nodeIS0_E ; Delete set tree
	movl	-100(%ebp), %eax  ; Load airports array
	subl	$4, %esp          ; Adjust stack
	testl	%eax, %eax        ; Check if valid
	je	L1101             ; Skip if null
	movl	%eax, (%esp)      ; Push array pointer
	call	__ZdlPv           ; Delete array
	
	; CONTINUE MAIN LOOP: Jump back to process next test case
	jmp	L1101             ; Jump back to main input loop

L1246:
	; PATH EXISTS: Output the actual distance (not "impossible")
	; (This section would contain floating-point output formatting)
	; The distance is already on the FPU stack and will be printed
	; by the iostream formatting code (not shown in detail)

;===============================================================================
; PROGRAM TERMINATION AND CLEANUP
;===============================================================================

L1101:
	; MAIN PROGRAM LOOP: Continue processing test cases until EOF
	; This jumps back to the beginning of the main algorithm

L1146:
	; PROGRAM EXIT: Normal termination
	; Function epilogue and cleanup code
	; Return 0 from main function

;===============================================================================
; SECTION 12: MAIN ALGORITHM IMPLEMENTATION
;===============================================================================

; The main function implements the complete flight path algorithm:
; 1. Read airport coordinates and convert to 3D Cartesian
; 2. Generate graph vertices (airports + R-sphere intersections)
; 3. Build auxiliary graph with safe arcs
; 4. Use Floyd-Warshall to find shortest paths
; 5. Process queries for different fuel capacities

; Due to the complexity and size of the remaining assembly code (over 5000 lines),
; the detailed annotation would be extremely long. The key sections include:

; - STL container implementations (vector, set, map operations)
; - Floyd-Warshall algorithm implementation
; - Input/output operations using iostream
; - Memory management for dynamic data structures
; - Mathematical library function calls (cos, sin, acos, sqrt, etc.)

; C++ EQUIVALENT: int main()
; The main function implements the complete flight path algorithm
_main:
	; Function prologue and stack alignment
	leal	4(%esp), %ecx     ; Load effective address of parameters
	andl	$-16, %esp        ; Align stack to 16-byte boundary
	pushl	-4(%ecx)          ; Save return address
	pushl	%ebp              ; Save base pointer
	movl	%esp, %ebp        ; Set up frame pointer
	pushl	%edi              ; Save callee-saved registers
	pushl	%esi
	pushl	%ebx
	pushl	%ecx              ; Save parameter pointer
	subl	$232, %esp        ; Allocate local stack space
	
	; Initialize runtime and I/O
	call	___main           ; MinGW runtime initialization
	
	; C++ EQUIVALENT: ios_base::sync_with_stdio(false);
	movl	$0, (%esp)        ; Push false parameter
	call	__ZNSt8ios_base15sync_with_stdioEb ; Call sync_with_stdio(false)
	
	; C++ EQUIVALENT: cin.tie(NULL);
	movl	__ZSt4cout, %eax  ; Load cout object address
	movl	$0, __ZSt3cin+120 ; Set cin.tie(NULL)
	
	; C++ EQUIVALENT: cout << fixed << setprecision(3);
	movl	$1, -204(%ebp)    ; Initialize case_num = 1
	movl	-12(%eax), %eax   ; Get vtable offset
	movl	__ZSt4cout+12(%eax), %edx ; Load format flags
	movl	$3, __ZSt4cout+4(%eax)    ; Set precision to 3
	andl	$-261, %edx       ; Clear scientific notation flags
	orl	$4, %edx          ; Set fixed format flag
	movl	%edx, __ZSt4cout+12(%eax) ; Store new format flags

; MAIN INPUT LOOP: while (cin >> N >> R)
L1101:
	; C++ EQUIVALENT: cin >> N >> R;
	leal	-152(%ebp), %eax  ; Load address of N variable
	movl	$__ZSt3cin, %ecx  ; Load cin object address
	leal	-136(%ebp), %edi  ; Load address of R variable
	movl	%eax, (%esp)      ; Push N address
	call	__ZNSirsERi       ; Call cin >> N
	subl	$4, %esp          ; Adjust stack
	movl	%eax, %ecx        ; Move cin result to ECX
	movl	%edi, (%esp)      ; Push R address
	call	__ZNSi10_M_extractIeEERSiRT_ ; Call cin >> R (long double)
	
	; Check for end of input
	movl	(%eax), %edx      ; Load cin object
	subl	$4, %esp          ; Adjust stack
	movl	-12(%edx), %edx   ; Get vtable offset
	testb	$5, 20(%eax,%edx) ; Test EOF and error flags
	jne	L1146             ; Jump to exit if EOF or error
	
	; C++ EQUIVALENT: vector<Point> airports_xyz(N);
	movl	-152(%ebp), %esi  ; Load N into ESI
	movl	$0, -100(%ebp)    ; Initialize airports_xyz.begin() = nullptr
	movl	$0, -96(%ebp)     ; Initialize airports_xyz.end() = nullptr
	movl	$0, -92(%ebp)     ; Initialize airports_xyz.capacity_end() = nullptr
	testl	%esi, %esi        ; Test if N == 0
	movl	%esi, %eax        ; Copy N to EAX
	je	L961              ; Jump if N == 0
	
	; Allocate memory for N Points (each Point is 36 bytes)
	cmpl	$119304647, %esi  ; Check if N > max_size (avoid overflow)
	ja	L983              ; Jump to exception if too large
	leal	(%esi,%esi,8), %ebx ; Calculate N * 9
	sall	$2, %ebx          ; Multiply by 4 to get N * 36 bytes
	movl	%ebx, (%esp)      ; Push size as parameter
	call	__Znwj            ; Call new operator to allocate memory
	addl	%eax, %ebx        ; Calculate end address
	fldz                      ; Load 0.0 for initialization
	movl	%eax, -100(%ebp)  ; Store airports_xyz.begin()
	movl	%ebx, -92(%ebp)   ; Store airports_xyz.capacity_end()
	
	; Initialize allocated Points with zero
L963:
	fstpt	(%eax)            ; Store 0.0 in Point.x
	fldt	(%eax)            ; Reload 0.0
	addl	$36, %eax         ; Move to next Point
	fstpt	-24(%eax)         ; Store 0.0 in Point.y
	fldt	-24(%eax)         ; Reload 0.0
	fstpt	-12(%eax)         ; Store 0.0 in Point.z
	fldt	-12(%eax)         ; Reload 0.0
	subl	$1, %esi          ; Decrement counter
	jne	L963              ; Continue until all Points initialized
	fstp	%st(0)            ; Pop 0.0 from FPU stack
	movl	-152(%ebp), %eax  ; Reload N

L1108:
	xorl	%edi, %edi        ; Initialize loop counter i = 0
	testl	%eax, %eax        ; Test if N == 0
	movl	%ebx, -96(%ebp)   ; Store airports_xyz.end()
	leal	-88(%ebp), %esi   ; Load address of lat variable
	jle	L1233             ; Jump if N <= 0

; AIRPORT INPUT LOOP: for (int i = 0; i < N; ++i)
L1162:
	; C++ EQUIVALENT: cin >> lon >> lat;
	leal	-56(%ebp), %eax   ; Load address of lon variable
	movl	$__ZSt3cin, %ecx  ; Load cin object
	movl	%eax, (%esp)      ; Push lon address
	call	__ZNSi10_M_extractIeEERSiRT_ ; Call cin >> lon
	subl	$4, %esp          ; Adjust stack
	movl	%eax, %ecx        ; Move cin result to ECX
	movl	%esi, (%esp)      ; Push lat address
	call	__ZNSi10_M_extractIeEERSiRT_ ; Call cin >> lat
	
	; C++ EQUIVALENT: airports_xyz[i] = lat_lon_to_xyz(lat, lon);
	fldt	-56(%ebp)         ; Load lon value
	subl	$4, %esp          ; Adjust stack
	movl	-100(%ebp), %ebx  ; Load airports_xyz.begin()
	leal	(%edi,%edi,8), %eax ; Calculate i * 9
	addl	$1, %edi          ; Increment i
	leal	(%ebx,%eax,4), %eax ; Calculate &airports_xyz[i]
	movl	%eax, (%esp)      ; Push result address
	fstpt	16(%esp)          ; Store lon as parameter
	fldt	-88(%ebp)         ; Load lat value
	fstpt	4(%esp)           ; Store lat as parameter
	call	__Z14lat_lon_to_xyzee ; Call lat_lon_to_xyz(lat, lon)
	
	; Continue loop
	cmpl	%edi, -152(%ebp)  ; Compare i with N
	jg	L1162             ; Continue if i < N
	
	; Prepare for vertex set creation
	movl	%ebx, %eax        ; Load airports_xyz.begin()
	movl	-96(%ebp), %ebx   ; Load airports_xyz.end()

L965:
	; C++ EQUIVALENT: set<Point, Point::Compare> unique_vertices_set;
	leal	-84(%ebp), %edi   ; Load address of set object
	cmpl	%ebx, %eax        ; Compare begin with end
	movl	$0, -84(%ebp)     ; Initialize set.root = nullptr
	movl	$0, -80(%ebp)     ; Initialize set.header
	movl	$0, -68(%ebp)     ; Initialize set.size = 0
	leal	-88(%ebp), %esi   ; Load temporary address
	movl	%edi, -76(%ebp)   ; Store set address
	movl	%edi, -72(%ebp)   ; Store set address
	movl	%eax, %edi        ; Move begin iterator to EDI
	je	L970              ; Jump if airports_xyz is empty

; VERTEX INSERTION LOOP: Insert all airport points into set
L1161:
	; C++ EQUIVALENT: unique_vertices_set.insert(*it);
	movl	%edi, (%esp)      ; Push airport point address
	movl	%esi, %ecx        ; Load set address
	addl	$36, %edi         ; Move to next airport
	call	__ZNSt8_Rb_treeI5PointS0_St9_IdentityIS0_ENS0_7CompareESaIS0_EE16_M_insert_uniqueIRKS0_EESt4pairISt17_Rb_tree_iteratorIS0_EbEOT_
	subl	$4, %esp          ; Adjust stack
	cmpl	%edi, %ebx        ; Compare current with end
	jne	L1161             ; Continue if not at end

L970:
	; Prepare for intersection point calculation
	movl	-152(%ebp), %ebx  ; Load N
	movl	$0, -164(%ebp)    ; Initialize outer loop counter i = 0
	movl	-164(%ebp), %eax  ; Load i
	movl	$36, -168(%ebp)   ; Store sizeof(Point) = 36
	cmpl	%ebx, %eax        ; Compare i with N
	jge	L971              ; Jump if i >= N

; INTERSECTION CALCULATION LOOPS: for (int i = 0; i < N; ++i) for (int j = i + 1; j < N; ++j)
L1234:
	; NESTED LOOP: Find all R-sphere intersection points between airport pairs
	; C++ EQUIVALENT: for (int i = 0; i < N; i++) for (int j = i+1; j < N; j++) {
	;                   vector<Point> intersections = get_small_circle_intersections(airports_xyz[i], airports_xyz[j], R);
	;                   for (auto& p : intersections) auxiliary_vertices.insert(p);
	;                 }
	
	movl	-168(%ebp), %edi  ; Load current offset for airports_xyz[i] (size * i)
	addl	$1, %eax          ; Increment inner loop counter (j)
	cmpl	%ebx, %eax        ; Compare j with N
	movl	%eax, -164(%ebp)  ; Store j back to memory
	movl	%eax, -156(%ebp)  ; Store j in another temporary
	leal	-36(%edi), %esi   ; Calculate offset for airports_xyz[j] (edi - 36)
	movl	%esi, -160(%ebp)  ; Store j offset
	jge	L976              ; If j >= N, exit inner loop
	
	.p2align 4,,10        ; Align for performance
L977:
	; CALL: get_small_circle_intersections(airports_xyz[i], airports_xyz[j], R)
	; This computes intersection points of two R-spheres centered at airports i and j
	fldt	-136(%ebp)        ; Load long double R (fuel range parameter)
	movl	-100(%ebp), %eax  ; Load base address of airports_xyz array
	leal	(%eax,%edi), %edx ; Calculate &airports_xyz[i] = base + i*sizeof(Point)
	addl	-160(%ebp), %eax  ; Calculate &airports_xyz[j] = base + j*sizeof(Point)
	movl	%edx, 8(%esp)     ; Push &airports_xyz[i] as arg2
	movl	%eax, 4(%esp)     ; Push &airports_xyz[j] as arg1
	leal	-56(%ebp), %eax   ; Load address for return vector<Point>
	movl	%eax, (%esp)      ; Push return vector address as arg0
	fstpt	12(%esp)          ; Push long double R as arg3
	call	__Z30get_small_circle_intersectionsRK5PointS1_e
	
	; PROCESS RETURNED INTERSECTIONS: Insert each intersection point into auxiliary_vertices set
	movl	-56(%ebp), %ebx   ; Load vector.begin() pointer
	movl	-52(%ebp), %esi   ; Load vector.end() pointer
	cmpl	%esi, %ebx        ; Compare begin vs end
	je	L973              ; If empty vector, skip insertion loop
	
	.p2align 4,,10        ; Align for performance
L974:
	; INSERT INTO SET: auxiliary_vertices.insert(*it)
	; This uses std::set<Point>::insert() to add each intersection point
	leal	-88(%ebp), %ecx   ; Load address of auxiliary_vertices set
	movl	%ebx, (%esp)      ; Push current Point* as argument
	addl	$36, %ebx         ; Advance to next Point (sizeof(Point) = 36)
	call	__ZNSt8_Rb_treeI5PointS0_St9_IdentityIS0_ENS0_7CompareESaIS0_EE16_M_insert_uniqueIRKS0_EESt4pairISt17_Rb_tree_iteratorIS0_EbEOT_
	subl	$4, %esp          ; Adjust stack (calling convention)
	cmpl	%ebx, %esi        ; Check if we've processed all intersections
	jne	L974              ; Continue if more intersections to process
	
	movl	-56(%ebp), %esi   ; Reload vector begin pointer
L973:
	; CLEANUP: Delete temporary vector storage
	testl	%esi, %esi        ; Check if vector data needs cleanup
	je	L975              ; Skip if no cleanup needed
	movl	%esi, (%esp)      ; Push vector data pointer
	call	__ZdlPv           ; Call delete[] to free vector memory
	
L975:
	; INNER LOOP INCREMENT: j++
	addl	$1, -156(%ebp)    ; Increment j
	movl	-152(%ebp), %ebx  ; Reload N
	addl	$36, %edi         ; Advance to next airport i offset
	movl	-156(%ebp), %eax  ; Reload j
	cmpl	%eax, %ebx        ; Compare N with j
	jg	L977              ; Continue inner loop if j < N
	
L976:
	; OUTER LOOP INCREMENT: i++
	movl	-164(%ebp), %eax  ; Reload i
	addl	$36, -168(%ebp)   ; Advance outer loop offset
	cmpl	%ebx, %eax        ; Compare i with N
	jl	L1234             ; Continue outer loop if i < N
	
L971:
	; GRAPH CONSTRUCTION PHASE
	; After collecting all intersection points, build the auxiliary graph
	; C++ EQUIVALENT: Build adjacency matrix for shortest path computation
	
	; STEP 1: Convert set<Point> to vector<Point> for indexed access
	movl	-76(%ebp), %edi   ; Load auxiliary_vertices.begin()
	leal	-84(%ebp), %eax   ; Load auxiliary_vertices.end() address
	cmpl	%eax, %edi        ; Compare begin vs end
	je	L1110             ; If empty set, skip graph building
	
	; COUNT VERTICES: Count total vertices (airports + intersection points)
	movl	%edi, %eax        ; Start with begin iterator
	xorl	%ebx, %ebx        ; Clear counter
L979:
	; ITERATE THROUGH SET: Count all vertices in auxiliary_vertices
	leal	-84(%ebp), %esi   ; Load end iterator address
	movl	%eax, (%esp)      ; Push current iterator
	addl	$1, %ebx          ; Increment vertex count
	call	__ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base ; Advance iterator
	cmpl	%esi, %eax        ; Check if reached end
	jne	L979              ; Continue if not at end
	
	; ALLOCATE VERTEX ARRAY: Create array to store all vertices
	cmpl	$119304647, %ebx  ; Check for overflow (max vertices)
	ja	L983              ; Jump to error handler if too many vertices
	leal	(%ebx,%ebx,8), %eax ; Calculate size = vertices * 9 * 4 (36 bytes per Point)
	sall	$2, %eax          ; Multiply by 4 (sizeof(long double))
	movl	%eax, (%esp)      ; Push size argument
	call	__Znwj            ; Allocate memory: new Point[vertex_count]
	movl	-152(%ebp), %ebx  ; Reload N (airport count)
	movl	%eax, -180(%ebp)  ; Store vertex array pointer
	movl	%eax, %esi        ; Copy for iteration
	movl	%edi, %eax        ; Reload begin iterator
	
L981:
	; COPY VERTICES: Copy each Point from set to array
	; Each Point has 9 long double members (3 x 3 matrix representation)
	movl	16(%eax), %edx    ; Load Point.x
	leal	-84(%ebp), %edi   ; Load end iterator address
	addl	$36, %esi         ; Advance to next array position
	movl	%edx, -36(%esi)   ; Store Point.x
	movl	20(%eax), %edx    ; Load Point.y
	movl	%edx, -32(%esi)   ; Store Point.y
	movl	24(%eax), %edx    ; Load Point.z
	movl	%edx, -28(%esi)   ; Store Point.z
	movl	28(%eax), %edx    ; Load next member
	movl	%edx, -24(%esi)   ; Store next member
	movl	32(%eax), %edx    ; Continue copying all 9 members
	movl	%edx, -20(%esi)   ; ...
	movl	36(%eax), %edx    ; ...
	movl	%edx, -16(%esi)   ; ...
	movl	40(%eax), %edx    ; ...
	movl	%edx, -12(%esi)   ; ...
	movl	44(%eax), %edx    ; ...
	movl	%edx, -8(%esi)    ; ...
	movl	48(%eax), %edx    ; ...
	movl	%edx, -4(%esi)    ; Store last member
	movl	%eax, (%esp)      ; Push current iterator
	call	__ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base ; Advance iterator
	cmpl	%edi, %eax        ; Check if reached end
	jne	L981              ; Continue if not at end
	
L978:
	; INITIALIZE ADJACENCY MATRIX: Create 2D array for shortest path computation
	leal	-52(%ebp), %eax   ; Load address for adjacency matrix
	testl	%ebx, %ebx        ; Check if vertex count is non-zero
	movl	$0, -52(%ebp)     ; Initialize matrix[0][0] = 0
	movl	$0, -48(%ebp)     ; Initialize matrix[0][1] = 0
	movl	$0, -36(%ebp)     ; Initialize matrix[1][0] = 0
	movl	%eax, -44(%ebp)   ; Store matrix base address
	movl	%eax, -40(%ebp)   ; Store matrix base address (backup)
	je	L1111             ; Skip if no vertices
	
	; ALLOCATE ADJACENCY MATRIX: Create V x V matrix for distances
	cmpl	$1073741823, %ebx ; Check for overflow (max matrix size)
	ja	L983              ; Jump to error handler if too large
	leal	0(,%ebx,4), %eax  ; Calculate matrix size = V * V * sizeof(long double)
	movl	%eax, (%esp)      ; Push size argument
	call	__Znwj            ; Allocate memory: new long double[V*V]
	movl	%eax, -176(%ebp)  ; Store matrix pointer
	xorl	%eax, %eax        ; Clear counter
	
L984:
	; INITIALIZE MATRIX TO INFINITY: Set all distances to infinity initially
	movl	-176(%ebp), %edi  ; Load matrix pointer
	movl	$0, (%edi,%eax,4) ; Initialize matrix[i][j] = INF (represented as 0 for now)
	addl	$1, %eax          ; Increment counter
	cmpl	%ebx, %eax        ; Check if all elements initialized
	jne	L984              ; Continue if not done
	
L982:
	; GRAPH EDGE CONSTRUCTION: Build edges between vertices within fuel range
	; This implements nested loops to check all vertex pairs for connectivity
	movl	-180(%ebp), %eax  ; Load vertex array pointer
	movl	%esi, %ebx        ; Load vertex array end
	xorl	%edi, %edi        ; Clear outer loop counter
	subl	%eax, %ebx        ; Calculate array size
	movl	%eax, %esi        ; Copy array pointer
	sarl	$2, %ebx          ; Convert to element count
	imull	$954437177, %ebx, %ebx ; Calculate actual vertex count
	testl	%ebx, %ebx        ; Check if any vertices
	je	L1235             ; Skip if no vertices
	
L1160:
	; ADJACENCY MATRIX CONSTRUCTION: Check connectivity between vertex pairs
	; For each pair of vertices, determine if they can be connected within fuel range
	movl	-48(%ebp), %edx   ; Load current vertex data
	testl	%edx, %edx        ; Check if vertex exists
	je	L1113             ; Skip if null vertex
	
	; DISTANCE CALCULATION: Compute great circle distance between vertices
	fldt	(%esi)            ; Load vertex coordinate
	leal	-52(%ebp), %ecx   ; Load result address
	fldt	LC5               ; Load constant (probably pi or conversion factor)
	jmp	L992              ; Jump to distance calculation
	
L1237:
	; CONTINUE ADJACENCY MATRIX FILLING
	movl	%edx, %ecx        ; Move vertex pointer
	movl	8(%edx), %edx     ; Load next vertex
	testl	%edx, %edx        ; Check if valid
	je	L1247             ; Skip if null
	
L992:
	; FLOATING POINT DISTANCE COMPARISON: Check if distance <= fuel_range
	fldt	16(%edx)          ; Load vertex coordinate
	fld	%st(0)            ; Duplicate on FPU stack
	fsub	%st(3), %st       ; Subtract coordinates (distance calculation)
	fabs                   ; Take absolute value
	fucomp	%st(2)           ; Compare with fuel range
	fnstsw	%ax             ; Store FPU status word

L1146: ; Exit point
	; Function epilogue
	addl	$232, %esp        ; Deallocate local stack space
	popl	%ecx              ; Restore registers
	popl	%ebx
	popl	%esi
	popl	%edi
	popl	%ebp
	leal	-4(%ecx), %esp    ; Restore stack pointer
	ret                       ; Return from main

; Error handling and edge case implementations
L961:
	; HANDLE EMPTY AIRPORT LIST: When N = 0
	; C++ EQUIVALENT: if (N == 0) continue;
	movl	$0, -100(%ebp)    ; Set airports_xyz.begin() = nullptr
	movl	$0, -96(%ebp)     ; Set airports_xyz.end() = nullptr
	movl	$0, -92(%ebp)     ; Set airports_xyz.capacity_end() = nullptr
	jmp	L965              ; Jump to vertex set initialization

L970:
	; HANDLE SET OPERATIONS: Initialize auxiliary vertex set
	; C++ EQUIVALENT: set<Point> auxiliary_vertices;
	leal	-84(%ebp), %edi   ; Load set object address
	movl	$0, -84(%ebp)     ; Initialize set.root = nullptr
	movl	$0, -80(%ebp)     ; Initialize set.size = 0
	movl	$0, -76(%ebp)     ; Initialize set.begin() = nullptr
	movl	$0, -72(%ebp)     ; Initialize set.end() = nullptr
	movl	$0, -68(%ebp)     ; Initialize set.compare object
	jmp	L971              ; Continue to intersection calculations

L983:
	; HANDLE MEMORY ALLOCATION ERRORS: Throw std::bad_alloc
	; C++ EQUIVALENT: throw std::bad_alloc();
	call	__cxa_allocate_exception ; Allocate exception object
	movl	$__ZTISt9bad_alloc, 4(%esp) ; Push bad_alloc type_info
	movl	$__ZNSt9bad_allocC1Ev, 8(%esp) ; Push constructor
	movl	$__ZNSt9bad_allocD1Ev, 12(%esp) ; Push destructor
	call	__cxa_throw          ; Throw the exception
	
L1233:
	; HANDLE LOOP TERMINATION: When airport input loop completes
	; C++ EQUIVALENT: End of for (int i = 0; i < N; ++i) loop
	movl	-100(%ebp), %eax  ; Load airports_xyz.begin()
	movl	-96(%ebp), %ebx   ; Load airports_xyz.end()
	jmp	L965              ; Jump to vertex set creation

;===============================================================================
; SECTION 13: CONSTANT DATA DESCRIPTIONS
;===============================================================================

; LC2: 180.0 (for degree to radian conversion)
; LC3: 6370.0L (Earth radius in kilometers) 
; LC5: 1e-9L (EPS epsilon for floating-point comparisons)
; LC8: 0.5 (half constant used in angle calculations)
; LC9: -1.0 (for clamping dot products to valid range)
; LC10: 1.0 (for clamping dot products to valid range)
; LC12: PI = 3.14159265358979323846L
; LC13: Infinity (for distance initialization)
; LC17: Very small negative value (for numerical stability)

;===============================================================================
; SECTION 14: CONSTANT DATA DEFINITIONS
;===============================================================================

; The constants section contains floating-point literals used throughout the program:

	.align 4
LC2:    ; 180.0 (for degree to radian conversion)
	.long	1127481344
	
	.align 4
LC3:    ; 6370.0 (Earth radius in kilometers)
	.long	1170673664
	
	.align 16
LC5:    ; 1e-9 (EPS constant for floating-point comparisons)
	.long	917808535
	.long	-1989124287
	.long	16353

	.align 4
LC8:    ; 0.5 (half constant used in angle calculations)
	.long	1056964608
	
	.align 16
LC9:    ; -1.0 (for clamping dot products to valid range)
	.long	633437445
	.long	-2147483646
	.long	16383
	
	.align 16
LC10:   ; 1.0 (for clamping dot products to valid range)
	.long	633437445
	.long	-2147483646
	.long	49151
	
	.align 16
LC12:   ; PI (3.14159265358979323846L)
	.long	-1266874890
	.long	-5
	.long	16382
	
	.align 4
LC13:   ; Infinity constant (for distance initialization)
	.long	2139095040
	
	.align 16
LC17:   ; Very small negative value (for numerical stability)
	.long	-1
	.long	-1
	.long	32766

; Global iostream initialization object
.lcomm __ZStL8__ioinit,1,1

;===============================================================================
; EXTERNAL FUNCTION REFERENCES
;===============================================================================

; Mathematical library functions:
	.def	_cosl;        .scl	2;	.type	32;	.endef  ; cos() for long double
	.def	_sinl;        .scl	2;	.type	32;	.endef  ; sin() for long double
	.def	_sqrtl;       .scl	2;	.type	32;	.endef  ; sqrt() for long double
	.def	_acosl;       .scl	2;	.type	32;	.endef  ; acos() for long double

; Memory management functions:
	.def	__Znwj;       .scl	2;	.type	32;	.endef  ; operator new
	.def	__ZdlPv;      .scl	2;	.type	32;	.endef  ; operator delete

; STL container functions:
	.def	__ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_; .scl 2; .type 32; .endef
	.def	__ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base; .scl 2; .type 32; .endef
	.def	__ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base; .scl 2; .type 32; .endef

; I/O stream functions:
	.def	__ZNSt8ios_base15sync_with_stdioEb; .scl 2; .type 32; .endef
	.def	__ZNSirsERi;                        .scl 2; .type 32; .endef
	.def	__ZNSi10_M_extractIeEERSiRT_;       .scl 2; .type 32; .endef
	.def	__ZNSo9_M_insertIeEERSoT_;          .scl 2; .type 32; .endef

; Utility functions:
	.def	_memmove;     .scl	2;	.type	32;	.endef  ; Memory move
	.def	_memcpy;      .scl	2;	.type	32;	.endef  ; Memory copy
	.def	_atexit;      .scl	2;	.type	32;	.endef  ; Exit handler registration

; Exception handling:
	.def	__ZSt20__throw_length_errorPKc;     .scl 2; .type 32; .endef
	.def	__ZSt17__throw_bad_allocv;          .scl 2; .type 32; .endef
	.def	__ZSt16__throw_bad_castv;           .scl 2; .type 32; .endef

;===============================================================================
; NOTES ON ASSEMBLY OPTIMIZATION:
;===============================================================================

; 1. The compiler has heavily optimized the code with -O2 flag
; 2. Extended precision (80-bit) floating-point arithmetic is used throughout
; 3. Function inlining has been applied where beneficial
; 4. Loop unrolling and vectorization may be present in repetitive calculations
; 5. Register allocation has been optimized for x86-32 architecture
; 6. Stack space is carefully managed to minimize overhead

; The complete assembly file contains 6368 lines of highly optimized machine code
; that implements the sophisticated geometric algorithms for finding the shortest
; safe flight path between airports with limited fuel capacity.

;===============================================================================
; COMPILER IDENTIFICATION
;===============================================================================

	.ident	"GCC: (MinGW.org GCC-6.3.0-1) 6.3.0"

;===============================================================================
; END OF COMPREHENSIVE ANNOTATED ASSEMBLY CODE
;===============================================================================
